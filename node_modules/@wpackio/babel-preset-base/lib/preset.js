"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preset = void 0;
const _excluded = ["presetEnv", "presetReact", "hasReact", "useReactJsxRuntime"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// tslint:disable no-any
const preset = (opts = {}) => {
  // from CRA
  // This is similar to how `env` works in Babel:
  // https://babeljs.io/docs/usage/babelrc/#env-option
  // We are not using `env` because it’s ignored in versions > babel-core@6.10.4:
  // https://github.com/babel/babel/issues/4539
  // https://github.com/facebook/create-react-app/issues/720
  // It’s also nice that we can enforce `NODE_ENV` being specified.
  const env = process.env.BABEL_ENV || process.env.NODE_ENV; // Extract this preset specific options and pass the rest to @babel/preset-env

  const _ref = opts || {},
        {
    presetEnv = {},
    presetReact = {},
    hasReact = true,
    useReactJsxRuntime = false
  } = _ref,
        noPlugins = _objectWithoutProperties(_ref, _excluded); // Create the presets


  const presets = [[require.resolve('@babel/preset-env'), _objectSpread({
    modules: env === 'test' ? 'commonjs' : false
  }, presetEnv)]]; // Add react if needed

  if (hasReact) {
    presets.push([require.resolve('@babel/preset-react'), _objectSpread({
      // Put development based on BABEL_ENV
      // Adds component stack to warning messages
      // Adds __self attribute to JSX which React will use for some warnings
      development: env !== 'production',
      // Will use the native built-in instead of trying to polyfill
      // behavior for any plugins that require one.
      useBuiltIns: true,
      runtime: useReactJsxRuntime ? 'automatic' : 'classic'
    }, presetReact)]);
  } // Create the plugins


  const plugins = [];
  const wannabePlugins = {
    noDynamicImport: require.resolve('@babel/plugin-syntax-dynamic-import'),
    noImportMeta: require.resolve('@babel/plugin-syntax-import-meta'),
    noClassProperties: [require.resolve('@babel/plugin-proposal-class-properties'), {
      loose: false
    }],
    noJsonStrings: require.resolve('@babel/plugin-proposal-json-strings'),
    noRuntime: [require.resolve('@babel/plugin-transform-runtime'), {
      corejs: false,
      helpers: true,
      regenerator: true,
      // We might wanna turn it on once node LTS has ESModules support
      useESModules: env !== 'test'
    }],
    noOptionalChaining: require.resolve('@babel/plugin-proposal-optional-chaining'),
    noNullishCoalescingOperator: require.resolve('@babel/plugin-proposal-nullish-coalescing-operator')
  }; // Add them, only if user hasn't explicitly disabled it

  Object.keys(wannabePlugins).forEach(pKey => {
    if (noPlugins[pKey] !== true) {
      plugins.push(wannabePlugins[pKey]);
    }
  }); // Necessary to include regardless of the environment because
  // in practice some other transforms (such as object-rest-spread)
  // don't work without it: https://github.com/babel/babel/issues/7215

  plugins.push([require.resolve('@babel/plugin-transform-destructuring'), {
    // Use loose mode for performance:
    // https://github.com/facebook/create-react-app/issues/5602
    loose: false,
    selectiveLoose: ['useState', 'useEffect', 'useContext', 'useReducer', 'useCallback', 'useMemo', 'useRef', 'useImperativeHandle', 'useLayoutEffect', 'useDebugValue']
  }]); // Return the preset and some of stage-3 plugins
  // We will remove them, once it becomes stage-4, i.e included in preset-env

  return {
    presets,
    plugins
  };
};

exports.preset = preset;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcmVzZXQudHMiXSwibmFtZXMiOlsicHJlc2V0Iiwib3B0cyIsImVudiIsInByb2Nlc3MiLCJCQUJFTF9FTlYiLCJOT0RFX0VOViIsInByZXNldEVudiIsInByZXNldFJlYWN0IiwiaGFzUmVhY3QiLCJ1c2VSZWFjdEpzeFJ1bnRpbWUiLCJub1BsdWdpbnMiLCJwcmVzZXRzIiwicmVxdWlyZSIsInJlc29sdmUiLCJtb2R1bGVzIiwicHVzaCIsImRldmVsb3BtZW50IiwidXNlQnVpbHRJbnMiLCJydW50aW1lIiwicGx1Z2lucyIsIndhbm5hYmVQbHVnaW5zIiwibm9EeW5hbWljSW1wb3J0Iiwibm9JbXBvcnRNZXRhIiwibm9DbGFzc1Byb3BlcnRpZXMiLCJsb29zZSIsIm5vSnNvblN0cmluZ3MiLCJub1J1bnRpbWUiLCJjb3JlanMiLCJoZWxwZXJzIiwicmVnZW5lcmF0b3IiLCJ1c2VFU01vZHVsZXMiLCJub09wdGlvbmFsQ2hhaW5pbmciLCJub051bGxpc2hDb2FsZXNjaW5nT3BlcmF0b3IiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInBLZXkiLCJzZWxlY3RpdmVMb29zZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUE4Qk8sTUFBTUEsTUFBTSxHQUFHLENBQUNDLElBQTBCLEdBQUcsRUFBOUIsS0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNQyxHQUFHLEdBQUdDLE9BQU8sQ0FBQ0QsR0FBUixDQUFZRSxTQUFaLElBQXlCRCxPQUFPLENBQUNELEdBQVIsQ0FBWUcsUUFBakQsQ0FSMEQsQ0FTMUQ7O0FBQ0EsZUFZSUosSUFBSSxJQUFJLEVBWlo7QUFBQSxRQUFNO0FBQ0xLLElBQUFBLFNBQVMsR0FBRyxFQURQO0FBRUxDLElBQUFBLFdBQVcsR0FBRyxFQUZUO0FBR0xDLElBQUFBLFFBQVEsR0FBRyxJQUhOO0FBSUxDLElBQUFBLGtCQUFrQixHQUFHO0FBSmhCLEdBQU47QUFBQSxRQVdJQyxTQVhKLDZDQVYwRCxDQXdCMUQ7OztBQUNBLFFBQU1DLE9BQXNCLEdBQUcsQ0FDOUIsQ0FDQ0MsT0FBTyxDQUFDQyxPQUFSLENBQWdCLG1CQUFoQixDQUREO0FBRUdDLElBQUFBLE9BQU8sRUFBRVosR0FBRyxLQUFLLE1BQVIsR0FBaUIsVUFBakIsR0FBOEI7QUFGMUMsS0FFb0RJLFNBRnBELEVBRDhCLENBQS9CLENBekIwRCxDQStCMUQ7O0FBQ0EsTUFBSUUsUUFBSixFQUFjO0FBQ2JHLElBQUFBLE9BQU8sQ0FBQ0ksSUFBUixDQUFhLENBQ1pILE9BQU8sQ0FBQ0MsT0FBUixDQUFnQixxQkFBaEIsQ0FEWTtBQUdYO0FBQ0E7QUFDQTtBQUNBRyxNQUFBQSxXQUFXLEVBQUVkLEdBQUcsS0FBSyxZQU5WO0FBT1g7QUFDQTtBQUNBZSxNQUFBQSxXQUFXLEVBQUUsSUFURjtBQVVYQyxNQUFBQSxPQUFPLEVBQUVULGtCQUFrQixHQUFHLFdBQUgsR0FBaUI7QUFWakMsT0FZUkYsV0FaUSxFQUFiO0FBZUEsR0FoRHlELENBa0QxRDs7O0FBQ0EsUUFBTVksT0FBNEIsR0FBRyxFQUFyQztBQUNBLFFBQU1DLGNBQStCLEdBQUc7QUFDdkNDLElBQUFBLGVBQWUsRUFBRVQsT0FBTyxDQUFDQyxPQUFSLENBQWdCLHFDQUFoQixDQURzQjtBQUV2Q1MsSUFBQUEsWUFBWSxFQUFFVixPQUFPLENBQUNDLE9BQVIsQ0FBZ0Isa0NBQWhCLENBRnlCO0FBR3ZDVSxJQUFBQSxpQkFBaUIsRUFBRSxDQUNsQlgsT0FBTyxDQUFDQyxPQUFSLENBQWdCLHlDQUFoQixDQURrQixFQUVsQjtBQUFFVyxNQUFBQSxLQUFLLEVBQUU7QUFBVCxLQUZrQixDQUhvQjtBQU92Q0MsSUFBQUEsYUFBYSxFQUFFYixPQUFPLENBQUNDLE9BQVIsQ0FBZ0IscUNBQWhCLENBUHdCO0FBUXZDYSxJQUFBQSxTQUFTLEVBQUUsQ0FDVmQsT0FBTyxDQUFDQyxPQUFSLENBQWdCLGlDQUFoQixDQURVLEVBRVY7QUFDQ2MsTUFBQUEsTUFBTSxFQUFFLEtBRFQ7QUFFQ0MsTUFBQUEsT0FBTyxFQUFFLElBRlY7QUFHQ0MsTUFBQUEsV0FBVyxFQUFFLElBSGQ7QUFJQztBQUNBQyxNQUFBQSxZQUFZLEVBQUU1QixHQUFHLEtBQUs7QUFMdkIsS0FGVSxDQVI0QjtBQWtCdkM2QixJQUFBQSxrQkFBa0IsRUFBRW5CLE9BQU8sQ0FBQ0MsT0FBUixDQUNuQiwwQ0FEbUIsQ0FsQm1CO0FBcUJ2Q21CLElBQUFBLDJCQUEyQixFQUFFcEIsT0FBTyxDQUFDQyxPQUFSLENBQzVCLG9EQUQ0QjtBQXJCVSxHQUF4QyxDQXBEMEQsQ0E2RTFEOztBQUNBb0IsRUFBQUEsTUFBTSxDQUFDQyxJQUFQLENBQVlkLGNBQVosRUFBNEJlLE9BQTVCLENBQXFDQyxJQUFELElBQWtCO0FBQ3JELFFBQUkxQixTQUFTLENBQUMwQixJQUFELENBQVQsS0FBb0IsSUFBeEIsRUFBOEI7QUFDN0JqQixNQUFBQSxPQUFPLENBQUNKLElBQVIsQ0FBYUssY0FBYyxDQUFDZ0IsSUFBRCxDQUEzQjtBQUNBO0FBQ0QsR0FKRCxFQTlFMEQsQ0FvRjFEO0FBQ0E7QUFDQTs7QUFDQWpCLEVBQUFBLE9BQU8sQ0FBQ0osSUFBUixDQUFhLENBQ1pILE9BQU8sQ0FBQ0MsT0FBUixDQUFnQix1Q0FBaEIsQ0FEWSxFQUVaO0FBQ0M7QUFDQTtBQUNBVyxJQUFBQSxLQUFLLEVBQUUsS0FIUjtBQUlDYSxJQUFBQSxjQUFjLEVBQUUsQ0FDZixVQURlLEVBRWYsV0FGZSxFQUdmLFlBSGUsRUFJZixZQUplLEVBS2YsYUFMZSxFQU1mLFNBTmUsRUFPZixRQVBlLEVBUWYscUJBUmUsRUFTZixpQkFUZSxFQVVmLGVBVmU7QUFKakIsR0FGWSxDQUFiLEVBdkYwRCxDQTRHMUQ7QUFDQTs7QUFDQSxTQUFPO0FBQ04xQixJQUFBQSxPQURNO0FBRU5RLElBQUFBO0FBRk0sR0FBUDtBQUlBLENBbEhNIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGUgbm8tYW55XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlc2V0T3B0aW9ucyB7XG5cdG5vRHluYW1pY0ltcG9ydD86IGJvb2xlYW47XG5cdG5vSW1wb3J0TWV0YT86IGJvb2xlYW47XG5cdG5vQ2xhc3NQcm9wZXJ0aWVzPzogYm9vbGVhbjtcblx0bm9Kc29uU3RyaW5ncz86IGJvb2xlYW47XG5cdG5vUnVudGltZT86IGJvb2xlYW47XG5cdGhhc1JlYWN0PzogYm9vbGVhbjtcblx0dXNlUmVhY3RKc3hSdW50aW1lPzogYm9vbGVhbjtcblx0cHJlc2V0RW52Pzoge307XG5cdHByZXNldFJlYWN0Pzoge307XG5cdFt4OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFiZWxQbHVnaW5Db25maWcge1xuXHRbeDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgdHlwZSBzaW5nbGVCYWJlbFBsdWdpbiA9IHN0cmluZyB8IFtzdHJpbmcsIEJhYmVsUGx1Z2luQ29uZmlnXTtcblxuZXhwb3J0IGludGVyZmFjZSBQb3NzaWJsZVBsdWdpbnMge1xuXHRbeDogc3RyaW5nXTogc2luZ2xlQmFiZWxQbHVnaW47XG59XG5cbmV4cG9ydCB0eXBlIGJhYmVsUHJlc2V0Q29uZmlndXJhdGlvbiA9IHtcblx0W3g6IHN0cmluZ106IGJvb2xlYW4gfCBzdHJpbmcgfCBiYWJlbFByZXNldENvbmZpZ3VyYXRpb247XG59O1xuZXhwb3J0IHR5cGUgYmFiZWxQcmVzZXQgPSBbc3RyaW5nXSB8IFtzdHJpbmcsIGJhYmVsUHJlc2V0Q29uZmlndXJhdGlvbl07XG5cbmV4cG9ydCBjb25zdCBwcmVzZXQgPSAob3B0czogUHJlc2V0T3B0aW9ucyB8IG51bGwgPSB7fSkgPT4ge1xuXHQvLyBmcm9tIENSQVxuXHQvLyBUaGlzIGlzIHNpbWlsYXIgdG8gaG93IGBlbnZgIHdvcmtzIGluIEJhYmVsOlxuXHQvLyBodHRwczovL2JhYmVsanMuaW8vZG9jcy91c2FnZS9iYWJlbHJjLyNlbnYtb3B0aW9uXG5cdC8vIFdlIGFyZSBub3QgdXNpbmcgYGVudmAgYmVjYXVzZSBpdOKAmXMgaWdub3JlZCBpbiB2ZXJzaW9ucyA+IGJhYmVsLWNvcmVANi4xMC40OlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzQ1Mzlcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvaXNzdWVzLzcyMFxuXHQvLyBJdOKAmXMgYWxzbyBuaWNlIHRoYXQgd2UgY2FuIGVuZm9yY2UgYE5PREVfRU5WYCBiZWluZyBzcGVjaWZpZWQuXG5cdGNvbnN0IGVudiA9IHByb2Nlc3MuZW52LkJBQkVMX0VOViB8fCBwcm9jZXNzLmVudi5OT0RFX0VOVjtcblx0Ly8gRXh0cmFjdCB0aGlzIHByZXNldCBzcGVjaWZpYyBvcHRpb25zIGFuZCBwYXNzIHRoZSByZXN0IHRvIEBiYWJlbC9wcmVzZXQtZW52XG5cdGNvbnN0IHtcblx0XHRwcmVzZXRFbnYgPSB7fSxcblx0XHRwcmVzZXRSZWFjdCA9IHt9LFxuXHRcdGhhc1JlYWN0ID0gdHJ1ZSxcblx0XHR1c2VSZWFjdEpzeFJ1bnRpbWUgPSBmYWxzZSxcblx0XHQvLyBQdXQgZXZlcnl0aGluZyBlbHNlIGluc2lkZSBub1BsdWdpbnMsIHdoaWNoIHdlIHdpbGwgdXNlIGxhdGVyXG5cdFx0Ly8gdG8gcHV0IG9yIGNhbmNlbCBvdXQgc3RhZ2UtMyBwbHVnaW5zLlxuXHRcdC8vIG5vRHluYW1pY0ltcG9ydCA9IGZhbHNlLFxuXHRcdC8vIG5vSW1wb3J0TWV0YSA9IGZhbHNlLFxuXHRcdC8vIG5vQ2xhc3NQcm9wZXJ0aWVzID0gZmFsc2UsXG5cdFx0Ly8gbm9Kc29uU3RyaW5ncyA9IGZhbHNlLFxuXHRcdC4uLm5vUGx1Z2luc1xuXHR9ID0gb3B0cyB8fCB7fTtcblxuXHQvLyBDcmVhdGUgdGhlIHByZXNldHNcblx0Y29uc3QgcHJlc2V0czogYmFiZWxQcmVzZXRbXSA9IFtcblx0XHRbXG5cdFx0XHRyZXF1aXJlLnJlc29sdmUoJ0BiYWJlbC9wcmVzZXQtZW52JyksXG5cdFx0XHR7IG1vZHVsZXM6IGVudiA9PT0gJ3Rlc3QnID8gJ2NvbW1vbmpzJyA6IGZhbHNlLCAuLi5wcmVzZXRFbnYgfSxcblx0XHRdLFxuXHRdO1xuXHQvLyBBZGQgcmVhY3QgaWYgbmVlZGVkXG5cdGlmIChoYXNSZWFjdCkge1xuXHRcdHByZXNldHMucHVzaChbXG5cdFx0XHRyZXF1aXJlLnJlc29sdmUoJ0BiYWJlbC9wcmVzZXQtcmVhY3QnKSxcblx0XHRcdHtcblx0XHRcdFx0Ly8gUHV0IGRldmVsb3BtZW50IGJhc2VkIG9uIEJBQkVMX0VOVlxuXHRcdFx0XHQvLyBBZGRzIGNvbXBvbmVudCBzdGFjayB0byB3YXJuaW5nIG1lc3NhZ2VzXG5cdFx0XHRcdC8vIEFkZHMgX19zZWxmIGF0dHJpYnV0ZSB0byBKU1ggd2hpY2ggUmVhY3Qgd2lsbCB1c2UgZm9yIHNvbWUgd2FybmluZ3Ncblx0XHRcdFx0ZGV2ZWxvcG1lbnQ6IGVudiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXHRcdFx0XHQvLyBXaWxsIHVzZSB0aGUgbmF0aXZlIGJ1aWx0LWluIGluc3RlYWQgb2YgdHJ5aW5nIHRvIHBvbHlmaWxsXG5cdFx0XHRcdC8vIGJlaGF2aW9yIGZvciBhbnkgcGx1Z2lucyB0aGF0IHJlcXVpcmUgb25lLlxuXHRcdFx0XHR1c2VCdWlsdEluczogdHJ1ZSxcblx0XHRcdFx0cnVudGltZTogdXNlUmVhY3RKc3hSdW50aW1lID8gJ2F1dG9tYXRpYycgOiAnY2xhc3NpYycsXG5cdFx0XHRcdC8vIEJ1dCBzcHJlYWQgbGF0ZXIsIHNvIHRoYXQgdXNlciBjYW4gb3ZlcnJpZGUgaXRcblx0XHRcdFx0Li4ucHJlc2V0UmVhY3QsXG5cdFx0XHR9LFxuXHRcdF0pO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIHRoZSBwbHVnaW5zXG5cdGNvbnN0IHBsdWdpbnM6IHNpbmdsZUJhYmVsUGx1Z2luW10gPSBbXTtcblx0Y29uc3Qgd2FubmFiZVBsdWdpbnM6IFBvc3NpYmxlUGx1Z2lucyA9IHtcblx0XHRub0R5bmFtaWNJbXBvcnQ6IHJlcXVpcmUucmVzb2x2ZSgnQGJhYmVsL3BsdWdpbi1zeW50YXgtZHluYW1pYy1pbXBvcnQnKSxcblx0XHRub0ltcG9ydE1ldGE6IHJlcXVpcmUucmVzb2x2ZSgnQGJhYmVsL3BsdWdpbi1zeW50YXgtaW1wb3J0LW1ldGEnKSxcblx0XHRub0NsYXNzUHJvcGVydGllczogW1xuXHRcdFx0cmVxdWlyZS5yZXNvbHZlKCdAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMnKSxcblx0XHRcdHsgbG9vc2U6IGZhbHNlIH0sXG5cdFx0XSxcblx0XHRub0pzb25TdHJpbmdzOiByZXF1aXJlLnJlc29sdmUoJ0BiYWJlbC9wbHVnaW4tcHJvcG9zYWwtanNvbi1zdHJpbmdzJyksXG5cdFx0bm9SdW50aW1lOiBbXG5cdFx0XHRyZXF1aXJlLnJlc29sdmUoJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXJ1bnRpbWUnKSxcblx0XHRcdHtcblx0XHRcdFx0Y29yZWpzOiBmYWxzZSxcblx0XHRcdFx0aGVscGVyczogdHJ1ZSxcblx0XHRcdFx0cmVnZW5lcmF0b3I6IHRydWUsXG5cdFx0XHRcdC8vIFdlIG1pZ2h0IHdhbm5hIHR1cm4gaXQgb24gb25jZSBub2RlIExUUyBoYXMgRVNNb2R1bGVzIHN1cHBvcnRcblx0XHRcdFx0dXNlRVNNb2R1bGVzOiBlbnYgIT09ICd0ZXN0Jyxcblx0XHRcdH0sXG5cdFx0XSxcblx0XHRub09wdGlvbmFsQ2hhaW5pbmc6IHJlcXVpcmUucmVzb2x2ZShcblx0XHRcdCdAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLW9wdGlvbmFsLWNoYWluaW5nJ1xuXHRcdCksXG5cdFx0bm9OdWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yOiByZXF1aXJlLnJlc29sdmUoXG5cdFx0XHQnQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1udWxsaXNoLWNvYWxlc2Npbmctb3BlcmF0b3InXG5cdFx0KSxcblx0fTtcblx0Ly8gQWRkIHRoZW0sIG9ubHkgaWYgdXNlciBoYXNuJ3QgZXhwbGljaXRseSBkaXNhYmxlZCBpdFxuXHRPYmplY3Qua2V5cyh3YW5uYWJlUGx1Z2lucykuZm9yRWFjaCgocEtleTogc3RyaW5nKSA9PiB7XG5cdFx0aWYgKG5vUGx1Z2luc1twS2V5XSAhPT0gdHJ1ZSkge1xuXHRcdFx0cGx1Z2lucy5wdXNoKHdhbm5hYmVQbHVnaW5zW3BLZXldKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIE5lY2Vzc2FyeSB0byBpbmNsdWRlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVudmlyb25tZW50IGJlY2F1c2Vcblx0Ly8gaW4gcHJhY3RpY2Ugc29tZSBvdGhlciB0cmFuc2Zvcm1zIChzdWNoIGFzIG9iamVjdC1yZXN0LXNwcmVhZClcblx0Ly8gZG9uJ3Qgd29yayB3aXRob3V0IGl0OiBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzcyMTVcblx0cGx1Z2lucy5wdXNoKFtcblx0XHRyZXF1aXJlLnJlc29sdmUoJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLWRlc3RydWN0dXJpbmcnKSxcblx0XHR7XG5cdFx0XHQvLyBVc2UgbG9vc2UgbW9kZSBmb3IgcGVyZm9ybWFuY2U6XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvNTYwMlxuXHRcdFx0bG9vc2U6IGZhbHNlLFxuXHRcdFx0c2VsZWN0aXZlTG9vc2U6IFtcblx0XHRcdFx0J3VzZVN0YXRlJyxcblx0XHRcdFx0J3VzZUVmZmVjdCcsXG5cdFx0XHRcdCd1c2VDb250ZXh0Jyxcblx0XHRcdFx0J3VzZVJlZHVjZXInLFxuXHRcdFx0XHQndXNlQ2FsbGJhY2snLFxuXHRcdFx0XHQndXNlTWVtbycsXG5cdFx0XHRcdCd1c2VSZWYnLFxuXHRcdFx0XHQndXNlSW1wZXJhdGl2ZUhhbmRsZScsXG5cdFx0XHRcdCd1c2VMYXlvdXRFZmZlY3QnLFxuXHRcdFx0XHQndXNlRGVidWdWYWx1ZScsXG5cdFx0XHRdLFxuXHRcdH0sXG5cdF0pO1xuXG5cdC8vIFJldHVybiB0aGUgcHJlc2V0IGFuZCBzb21lIG9mIHN0YWdlLTMgcGx1Z2luc1xuXHQvLyBXZSB3aWxsIHJlbW92ZSB0aGVtLCBvbmNlIGl0IGJlY29tZXMgc3RhZ2UtNCwgaS5lIGluY2x1ZGVkIGluIHByZXNldC1lbnZcblx0cmV0dXJuIHtcblx0XHRwcmVzZXRzLFxuXHRcdHBsdWdpbnMsXG5cdH07XG59O1xuIl19
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebpackConfigHelper = void 0;

var _cleanWebpackPlugin = require("clean-webpack-plugin");

var _miniCssExtractPlugin = _interopRequireDefault(require("mini-css-extract-plugin"));

var _path = _interopRequireDefault(require("path"));

var _slugify = _interopRequireDefault(require("slugify"));

var _timeFixPlugin = _interopRequireDefault(require("time-fix-plugin"));

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackAssetsManifest = _interopRequireDefault(require("webpack-assets-manifest"));

var _reactRefreshWebpackPlugin = _interopRequireDefault(require("@pmmmwh/react-refresh-webpack-plugin"));

var _DependencyExtractionWebpackPlugin = require("../plugins/DependencyExtractionWebpackPlugin");

var _devUtils = require("../dev-utils");

var _WpackioError = require("../errors/WpackioError");

var _babelConfig = require("./babelConfig");

var _loaderHelpers = require("./loaderHelpers");

var _ops = require("../dev-utils/ops");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A helper class to get different configuration of webpack.
 */
class WebpackConfigHelper {
  // This is where all the filename will be prefixed, so we create a directory
  // Actual outputPath as provided by user

  /**
   * Context directory, from where we read the stuff and put stuff.
   */

  /**
   * Simulated NODE_ENV string, used internally and defined
   * in webpack with webpack.DefinePlugin.
   */

  /**
   * Create an instance of GetEntryAndOutput class.
   */
  constructor(file, config, cwd, isDev = true) {
    _defineProperty(this, "appDir", void 0);

    _defineProperty(this, "outputPath", void 0);

    _defineProperty(this, "file", void 0);

    _defineProperty(this, "isDev", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "cwd", void 0);

    _defineProperty(this, "env", void 0);

    this.file = file;
    this.config = config;
    this.cwd = cwd;
    this.isDev = isDev;

    if (isDev) {
      this.env = 'development';
    } else {
      this.env = 'production';
    } // Create the outputPath, because we would be needing that


    const {
      outputPath
    } = this.config; // and filename and inner directory name
    // this innerDir will be prefixed to all filename
    // because for multi-compiler to work, we need
    // outputPath and publicPath themselves on the same path.
    // all middlewares would actually use the `name` from webpack config
    // to separate updates.

    const {
      name
    } = this.file;
    this.appDir = (0, _slugify.default)(name, {
      lower: true
    });
    this.outputPath = _path.default.join(this.cwd, outputPath);
  }

  static getHmrPath() {
    return `/__wpackio_hmr`;
  }
  /**
   * Get webpack compatible entry configuration.
   *
   * The entry object has members which always has string[].
   * This is to ensure that we can insert the hot loader client
   * when necessary.
   */


  getEntry() {
    // First destructure away the stuff we need
    const {
      name,
      entry
    } = this.file; // We intend to pass the entry directly to webpack,
    // but, we need to add the hot-middleware client to the entry
    // else it will simply not work

    const normalizedEntry = {}; // Loop over all user defined entries and add to the normalizedEntry

    Object.keys(entry).forEach(key => {
      // We have to break and take the value in a separate
      // variable, otherwise typescript says all the weird
      // thing ðŸ˜¢
      // https://github.com/Microsoft/TypeScript/issues/10442#issuecomment-426203863
      const entryPoint = entry[key];
      normalizedEntry[key] = Array.isArray(entryPoint) ? // maybe we can go a step futher and put an entry point which takes
      // care of the __webpack_public_path__
      // like `@wpackio/publicpath?outputPath=${this.config.outputPath}&appName=${this.config.appName}`
      entryPoint : [entryPoint];
    }); // Now, if in dev mode, then add the hot middleware client

    if (this.isDev) {
      // Whether or not we use the react-refresh and family, we need the default
      // whm client for this to work.
      // Custom overlay and it's styling
      // Custom style
      const overlayStyles = {
        zIndex: 999999999,
        fontSize: '14px',
        fontFamily: 'Dank Mono, Operator Mono SSm, Operator Mono, Menlo, Consolas, monospace',
        padding: '32px 16px'
      }; // Define the hot client string
      //
      // Here we need
      // 1. client - because it needs to be consistent across this and WHM.
      // 2. overlay and overlayStypes - To enable overlay on errors, we don't need warnings here
      // 3. path - The output path, We need to make sure both server and client has the same value.
      // 4. name - Because it could be multicompiler

      const webpackHotClient = `webpack-hot-middleware/client?path=${WebpackConfigHelper.getHmrPath()}&name=${name}${this.config.errorOverlay ? '&overlay=true' : ''}&reload=true&overlayStyles=${encodeURIComponent(JSON.stringify(overlayStyles))}`; // Now add to each of the entries
      // We don't know if user want to specifically disable for some, but let's
      // not think ahead of ourselves

      Object.keys(normalizedEntry).forEach(key => {
        normalizedEntry[key] = [// put webpack hot client in the entry at the top
        // otherwise HMR will stop working after an update
        webpackHotClient, ...normalizedEntry[key]];
      });
    } else {
      // Put the publicPath entry point
      Object.keys(normalizedEntry).forEach(key => {
        normalizedEntry[key] = [// We need it before any other entrypoint, otherwise it won't
        // work, if ES Modules are used.
        `@wpackio/entrypoint/lib/index`, ...normalizedEntry[key]];
      });
    }

    return normalizedEntry;
  }
  /**
   * Get webpack compatible output object.
   */


  getOutput() {
    // Assuming it is production
    const output = {
      // Here we create a directory inside the user provided outputPath
      // The name of the directory is the sluggified verion of `name`
      // of this configuration object.
      // Also here we assume, user has passed in the correct `relative`
      // path for `outputPath`. Otherwise this will break.
      // We do not use path.resolve, because we expect outputPath to be
      // relative. @todo: create a test here
      path: this.outputPath,
      filename: `${this.appDir}/${this.isDev ? '[name]' : '[name]-[contenthash:8]'}.js`,
      // leave blank because we would handle with free variable
      // __webpack_public_path__ in runtime.
      publicPath: '',
      // we need different jsonpFunction, it has to
      // be unique for every webpack config, otherwise
      // the later will override the previous
      // having combination of appName and file.name
      // kind of ensures that billions of devs, don't
      // override each other!!!!
      jsonpFunction: `wpackio${this.config.appName}${this.file.name}Jsonp`
    }; // Add the publicPath if it is in devMode

    if (this.isDev) {
      // This is calculated by CreateWebpackConfig
      // taking into consideration user's own value.
      // So, if WordPress defaults are changed, then
      // depending on wpackio.server.js, it will still
      // point to the right location. It only makes
      // dynamic import and some on-demand split-chunk
      // work.
      output.publicPath = this.config.publicPathUrl;
    }

    return output;
  }
  /**
   * Get WebPack plugins, depending on development or production
   */


  getPlugins() {
    // Add common plugins
    let plugins = [// Define env
    new _webpack.default.DefinePlugin(_objectSpread(_objectSpread({
      'process.env.NODE_ENV': JSON.stringify(this.env),
      'process.env.BABEL_ENV': JSON.stringify(this.env)
    }, this.getEnvVariables()), {}, {
      // Our own access to project config from the modules
      // mainly needed for the publicPath entrypoint
      __WPACKIO__: {
        appName: JSON.stringify(this.config.appName),
        outputPath: JSON.stringify(this.config.outputPath)
      }
    })), // Clean dist directory
    new _cleanWebpackPlugin.CleanWebpackPlugin({
      verbose: false,
      cleanOnceBeforeBuildPatterns: [`${this.outputPath}/${this.appDir}`]
    }), // Initiate mini css extract
    new _miniCssExtractPlugin.default({
      filename: `${this.appDir}/${this.isDev ? '[name]' : '[name]-[contenthash:8]'}.css`,
      // we do it this way, so that we can easily setup e2e tests, we can always predict what the name would be
      ignoreOrder: false
    }), // Create Manifest for PHP Consumption
    new _webpackAssetsManifest.default({
      writeToDisk: true,
      output: `${this.outputPath}/${this.appDir}/manifest.json`,
      publicPath: ``,
      // We dont put ${this.config.outputPath}/ here because, PHP will pick it up anyway.
      entrypoints: true,
      entrypointsKey: 'wpackioEp'
    })]; // Add ts checker plugin if project has tsconfig.json

    const [isTs, tsconfigPath] = (0, _ops.hasTypeScript)(this.cwd);

    if (isTs && this.file.hasTypeScript !== false) {
      // dynamic require forktschecker otherwise it will throw error
      try {
        // eslint-disable-next-line import/no-extraneous-dependencies, global-require, @typescript-eslint/no-var-requires
        const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');

        plugins.push(new ForkTsCheckerWebpackPlugin({
          async: this.isDev,
          typescript: {
            configFile: tsconfigPath,
            mode: 'write-references'
          },
          eslint: undefined,
          formatter: 'codeframe',
          logger: {
            infrastructure: 'silent',
            issues: 'silent'
          }
        }));
      } catch (e) {
        throw new _WpackioError.WpackioError(e);
      }
    } // Add wordpress dependency extract plugin


    if (this.config.disableWordPressExternals !== true) {
      var _this$file$optimizeFo;

      plugins.push(new _DependencyExtractionWebpackPlugin.DependencyExtractionWebpackPlugin({
        gutenbergOptimized: (_this$file$optimizeFo = this.file.optimizeForGutenberg) !== null && _this$file$optimizeFo !== void 0 ? _this$file$optimizeFo : false,
        appDir: this.appDir
      }));
    } // Add development specific plugins


    if (this.isDev) {
      // Hot Module Replacement
      plugins.push(new _webpack.default.HotModuleReplacementPlugin()); // If you require a missing module and then `npm install` it, you still have
      // to restart the development server for Webpack to discover it. This plugin
      // makes the discovery automatic so you don't have to restart.
      // See https://github.com/facebook/create-react-app/issues/186

      plugins.push(new _devUtils.WatchMissingNodeModulesPlugin(_path.default.resolve(this.cwd, './node_modules'))); // Add timewatch plugin to avoid multiple successive build
      // https://github.com/webpack/watchpack/issues/25

      plugins = [new _timeFixPlugin.default(), ...plugins]; // Add react refresh if needed

      if (this.config.hasReact && !this.config.disableReactRefresh && !this.file.optimizeForGutenberg) {
        plugins.push(new _reactRefreshWebpackPlugin.default({
          overlay: {
            sockIntegration: 'whm'
          }
        }));
      }
    } else {
      // Add Production specific plugins
      const {
        bannerConfig
      } = this.config;
      const creditNote = '\n\nCompiled with the help of https://wpack.io\nA zero setup Webpack Bundler Script for WordPress';
      plugins.push( // Banner plugin
      new _webpack.default.BannerPlugin({
        entryOnly: false,
        raw: false,
        // Add to ts, tsx, css, scss, sass
        include: /\.((t|j)sx?|s?(c|a)ss)$/,
        banner: `
${bannerConfig.name}

@author ${bannerConfig.author}
@version ${bannerConfig.version}
@link ${bannerConfig.link}
@license ${bannerConfig.license}

Copyright (c) ${new Date().getFullYear()} ${bannerConfig.author}

${bannerConfig.copyrightText}${bannerConfig.credit ? creditNote : ''}`
      }));
    } // Return it


    return plugins;
  }
  /**
   * Get module object for webpack, depending on environment.
   */


  getModule() {
    const {
      hasReact,
      hasSass,
      hasFlow,
      hasLess
    } = this.config;
    const wpackioBabelOptions = {
      hasReact,
      // use react jsx runtime only if enabled explicitly
      // and not optimizing for gutenberg
      useReactJsxRuntime: this.config.useReactJsxRuntime && !this.file.optimizeForGutenberg
    }; // check if babel.config.js is present

    const isBabelConfigPresent = this.config.useBabelConfig; // Push targets to babel-preset-env if this is dev
    // We target only the latest chrome and firefox for
    // greater speed

    if (this.isDev) {
      wpackioBabelOptions.presetEnv = {
        targets: {
          chrome: '69',
          firefox: '62',
          edge: '17'
        }
      };
    } // create the babel rules for es6+ code


    const jsPresets = (0, _babelConfig.getBabelPresets)((0, _babelConfig.overrideBabelPresetOptions)(wpackioBabelOptions, this.config.jsBabelPresetOptions), hasFlow ? 'flow' : undefined);
    const jsRules = {
      test: /\.m?jsx?$/,
      use: [{
        loader: require.resolve('babel-loader'),
        options: this.getFinalBabelLoaderOptions(isBabelConfigPresent ? {} : this.getOverrideWebpackRuleOptions({
          presets: jsPresets,
          // disable babelrc and babel.config.js
          // as it could potentially break stuff
          // rather use the jsBabelOverride
          configFile: false,
          babelrc: false
        }, this.config.jsBabelOverride))
      }],
      exclude: /(node_modules|bower_components)/
    }; // create the babel rules for typescript code

    const tsPresets = (0, _babelConfig.getBabelPresets)((0, _babelConfig.overrideBabelPresetOptions)(wpackioBabelOptions, this.config.tsBabelPresetOptions), 'typescript');
    const tsRules = {
      test: /\.tsx?$/,
      use: [{
        loader: require.resolve('babel-loader'),
        options: this.getFinalBabelLoaderOptions(isBabelConfigPresent ? {} : this.getOverrideWebpackRuleOptions({
          presets: tsPresets,
          // disable babelrc and babel.config.js
          // as it could potentially break stuff
          // rather use the jsBabelOverride
          configFile: false,
          babelrc: false // We don't need plugin-proposal-class-properties
          // because taken care of by @wpackio/base
          // '@babel/proposal-class-properties',
          // We don't need object-rest-spread because it is
          // already in stage-4 and taken care of by preset-env
          // '@babel/proposal-object-rest-spread',

        }, this.config.tsBabelOverride))
      }],
      exclude: /(node_modules)/
    }; // Compile node_modules

    const nmJsRules = {
      test: /\.(js|mjs)$/,
      // we exclude @babel/runtime and core-js
      exclude: /(@babel(?:\/|\\{1,2})runtime)|(core-js)/,
      include: /node_modules/,
      use: [{
        loader: require.resolve('babel-loader'),
        options: this.getFinalBabelLoaderOptions({
          // preset from our own package
          presets: (0, _babelConfig.getBabelPresets)({
            hasReact: false
          }),
          // If an error happens in a package, it's possible to be
          // because it was compiled. Thus, we don't want the browser
          // debugger to show the original code. Instead, the code
          // being evaluated would be much more helpful.
          sourceMaps: false,
          // Babel assumes ES Modules, which isn't safe until CommonJS
          // dies. This changes the behavior to assume CommonJS unless
          // an `import` or `export` is present in the file.
          // https://github.com/webpack/webpack/issues/4039#issuecomment-419284940
          sourceType: 'unambiguous',
          // disable babelrc and babel.config.js for node_modules
          configFile: false,
          babelrc: false
        }, false)
      }]
    }; // Create style rules

    const styleRules = [{
      test: /\.css$/,
      use: [...(0, _loaderHelpers.getStyleLoaderUses)(this.isDev, this.config.publicPathUrl, false)]
    }]; // If we have sass, then add the stuff

    if (hasSass) {
      styleRules.push({
        test: /\.s(a|c)ss$/,
        use: [...(0, _loaderHelpers.getStyleLoaderUses)(this.isDev, this.config.publicPathUrl, true), {
          loader: require.resolve('sass-loader'),
          options: {
            sourceMap: true
          }
        }]
      });
    } // If we have less, then add the stuff


    if (hasLess) {
      styleRules.push({
        test: /\.less$/,
        use: [...(0, _loaderHelpers.getStyleLoaderUses)(this.isDev, this.config.publicPathUrl, true), {
          loader: require.resolve('less-loader'),
          options: {
            sourceMap: true,
            lessOptions: {
              javascriptEnabled: true
            }
          }
        }]
      });
    } // create file rules


    const {
      fileRulesNonStyle,
      fileRulesStyle
    } = (0, _loaderHelpers.getFileLoaderForJsAndStyleAssets)(this.appDir, this.isDev);
    const rules = [jsRules, tsRules];

    if (this.isDev && this.config.compileNodeModules.dev) {
      rules.push(nmJsRules);
    } else if (!this.isDev && this.config.compileNodeModules.prod) {
      rules.push(nmJsRules);
    }

    rules.push(...styleRules, fileRulesNonStyle, fileRulesStyle);
    return {
      rules
    };
  }
  /**
   * Get webpack compatible resolve property.
   */


  getResolve() {
    return {
      extensions: ['.mjs', '.js', '.jsx', '.ts', '.tsx'],
      alias: this.config.alias !== undefined ? _objectSpread({}, this.config.alias) : {}
    };
  }
  /**
   * Get optimization for webpack.
   *
   * We optimize all chunks because
   */


  getOptimization() {
    const {
      optimizeSplitChunks
    } = this.config;
    const optimization = {
      // We set runtimeChunk to be single
      // because user can (and probably should)
      // have multiple entry-point on the same page
      runtimeChunk: 'single'
    };

    if (optimizeSplitChunks) {
      optimization.splitChunks = {
        chunks: 'all',
        minSize: 30000,
        minChunks: 1,
        maxAsyncRequests: 5,
        maxInitialRequests: 3,
        name: true,
        cacheGroups: {
          vendors: {
            test: /[\\/]node_modules[\\/]/,
            priority: -10
          },
          default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true
          }
        }
      };
    }

    return optimization;
  }
  /**
   * Get common configuration, depending on just environment.
   */


  getCommon() {
    return {
      context: this.cwd,
      devtool: this.isDev ? 'cheap-module-source-map' : 'source-map',
      target: 'web',
      watch: this.isDev,
      mode: this.env,
      name: this.file.name,
      externals: this.config.externals,
      infrastructureLogging: {
        level: 'none'
      }
    };
  }
  /**
   * Get final babel loader options. This adds anything necessary for
   * wpackio functions.
   *
   * @param options Existing babel loader options.
   */


  getFinalBabelLoaderOptions(options, addReactRefresh = true) {
    const finalOptions = options && typeof options === 'object' ? _objectSpread({}, options) : {};

    if (this.config.hasReact && !this.config.disableReactRefresh && !this.file.optimizeForGutenberg && addReactRefresh && this.isDev) {
      if (!finalOptions.plugins) {
        finalOptions.plugins = [];
      }

      finalOptions.plugins.push(require.resolve('react-refresh/babel'));
    }

    const babelLoaderCacheOptions = {
      // This is a feature of `babel-loader` for webpack (not Babel itself).
      // It enables caching results in ./node_modules/.cache/babel-loader/
      // directory for faster rebuilds.
      cacheDirectory: true,
      cacheCompression: !this.isDev,
      compact: !this.isDev
    };
    return _objectSpread(_objectSpread({}, finalOptions), babelLoaderCacheOptions);
  }
  /**
   * Get final loader option based on user and system.
   *
   * @param defaults Default options as calculated by system.
   * @param override User defined option.
   */


  getOverrideWebpackRuleOptions(defaults, override) {
    // If override is not undefined or null, then return it
    if (override !== undefined) {
      // If it is a function
      if (typeof override === 'function') {
        return override(defaults || {});
      }

      return override;
    } // Otherwise just return default


    return defaults;
  }

  getEnvVariables() {
    var _process$env;

    const envVariables = {};
    const match = 'WPACKIO_';
    Object.keys((_process$env = process.env) !== null && _process$env !== void 0 ? _process$env : {}).forEach(key => {
      if (key.startsWith(match)) {
        envVariables[`process.env.${key.substring(match.length)}`] = JSON.stringify(process.env[key]);
      }
    });
    return envVariables;
  }
  /**
   * Get calculated app directory
   */


  getAppDir() {
    return this.appDir;
  }

}

exports.WebpackConfigHelper = WebpackConfigHelper;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb25maWcvV2VicGFja0NvbmZpZ0hlbHBlci50cyJdLCJuYW1lcyI6WyJXZWJwYWNrQ29uZmlnSGVscGVyIiwiY29uc3RydWN0b3IiLCJmaWxlIiwiY29uZmlnIiwiY3dkIiwiaXNEZXYiLCJlbnYiLCJvdXRwdXRQYXRoIiwibmFtZSIsImFwcERpciIsImxvd2VyIiwicGF0aCIsImpvaW4iLCJnZXRIbXJQYXRoIiwiZ2V0RW50cnkiLCJlbnRyeSIsIm5vcm1hbGl6ZWRFbnRyeSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiZW50cnlQb2ludCIsIkFycmF5IiwiaXNBcnJheSIsIm92ZXJsYXlTdHlsZXMiLCJ6SW5kZXgiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJwYWRkaW5nIiwid2VicGFja0hvdENsaWVudCIsImVycm9yT3ZlcmxheSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRPdXRwdXQiLCJvdXRwdXQiLCJmaWxlbmFtZSIsInB1YmxpY1BhdGgiLCJqc29ucEZ1bmN0aW9uIiwiYXBwTmFtZSIsInB1YmxpY1BhdGhVcmwiLCJnZXRQbHVnaW5zIiwicGx1Z2lucyIsIndlYnBhY2siLCJEZWZpbmVQbHVnaW4iLCJnZXRFbnZWYXJpYWJsZXMiLCJfX1dQQUNLSU9fXyIsIkNsZWFuV2VicGFja1BsdWdpbiIsInZlcmJvc2UiLCJjbGVhbk9uY2VCZWZvcmVCdWlsZFBhdHRlcm5zIiwiTWluaUNzc0V4dHJhY3RQbHVnaW4iLCJpZ25vcmVPcmRlciIsIldlYnBhY2tBc3NldHNNYW5pZmVzdCIsIndyaXRlVG9EaXNrIiwiZW50cnlwb2ludHMiLCJlbnRyeXBvaW50c0tleSIsImlzVHMiLCJ0c2NvbmZpZ1BhdGgiLCJoYXNUeXBlU2NyaXB0IiwiRm9ya1RzQ2hlY2tlcldlYnBhY2tQbHVnaW4iLCJyZXF1aXJlIiwicHVzaCIsImFzeW5jIiwidHlwZXNjcmlwdCIsImNvbmZpZ0ZpbGUiLCJtb2RlIiwiZXNsaW50IiwidW5kZWZpbmVkIiwiZm9ybWF0dGVyIiwibG9nZ2VyIiwiaW5mcmFzdHJ1Y3R1cmUiLCJpc3N1ZXMiLCJlIiwiV3BhY2tpb0Vycm9yIiwiZGlzYWJsZVdvcmRQcmVzc0V4dGVybmFscyIsIkRlcGVuZGVuY3lFeHRyYWN0aW9uV2VicGFja1BsdWdpbiIsImd1dGVuYmVyZ09wdGltaXplZCIsIm9wdGltaXplRm9yR3V0ZW5iZXJnIiwiSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4iLCJXYXRjaE1pc3NpbmdOb2RlTW9kdWxlc1BsdWdpbiIsInJlc29sdmUiLCJUaW1lRml4UGx1Z2luIiwiaGFzUmVhY3QiLCJkaXNhYmxlUmVhY3RSZWZyZXNoIiwiUmVhY3RSZWZyZXNoV2VicGFja1BsdWdpbiIsIm92ZXJsYXkiLCJzb2NrSW50ZWdyYXRpb24iLCJiYW5uZXJDb25maWciLCJjcmVkaXROb3RlIiwiQmFubmVyUGx1Z2luIiwiZW50cnlPbmx5IiwicmF3IiwiaW5jbHVkZSIsImJhbm5lciIsImF1dGhvciIsInZlcnNpb24iLCJsaW5rIiwibGljZW5zZSIsIkRhdGUiLCJnZXRGdWxsWWVhciIsImNvcHlyaWdodFRleHQiLCJjcmVkaXQiLCJnZXRNb2R1bGUiLCJoYXNTYXNzIiwiaGFzRmxvdyIsImhhc0xlc3MiLCJ3cGFja2lvQmFiZWxPcHRpb25zIiwidXNlUmVhY3RKc3hSdW50aW1lIiwiaXNCYWJlbENvbmZpZ1ByZXNlbnQiLCJ1c2VCYWJlbENvbmZpZyIsInByZXNldEVudiIsInRhcmdldHMiLCJjaHJvbWUiLCJmaXJlZm94IiwiZWRnZSIsImpzUHJlc2V0cyIsImpzQmFiZWxQcmVzZXRPcHRpb25zIiwianNSdWxlcyIsInRlc3QiLCJ1c2UiLCJsb2FkZXIiLCJvcHRpb25zIiwiZ2V0RmluYWxCYWJlbExvYWRlck9wdGlvbnMiLCJnZXRPdmVycmlkZVdlYnBhY2tSdWxlT3B0aW9ucyIsInByZXNldHMiLCJiYWJlbHJjIiwianNCYWJlbE92ZXJyaWRlIiwiZXhjbHVkZSIsInRzUHJlc2V0cyIsInRzQmFiZWxQcmVzZXRPcHRpb25zIiwidHNSdWxlcyIsInRzQmFiZWxPdmVycmlkZSIsIm5tSnNSdWxlcyIsInNvdXJjZU1hcHMiLCJzb3VyY2VUeXBlIiwic3R5bGVSdWxlcyIsInNvdXJjZU1hcCIsImxlc3NPcHRpb25zIiwiamF2YXNjcmlwdEVuYWJsZWQiLCJmaWxlUnVsZXNOb25TdHlsZSIsImZpbGVSdWxlc1N0eWxlIiwicnVsZXMiLCJjb21waWxlTm9kZU1vZHVsZXMiLCJkZXYiLCJwcm9kIiwiZ2V0UmVzb2x2ZSIsImV4dGVuc2lvbnMiLCJhbGlhcyIsImdldE9wdGltaXphdGlvbiIsIm9wdGltaXplU3BsaXRDaHVua3MiLCJvcHRpbWl6YXRpb24iLCJydW50aW1lQ2h1bmsiLCJzcGxpdENodW5rcyIsImNodW5rcyIsIm1pblNpemUiLCJtaW5DaHVua3MiLCJtYXhBc3luY1JlcXVlc3RzIiwibWF4SW5pdGlhbFJlcXVlc3RzIiwiY2FjaGVHcm91cHMiLCJ2ZW5kb3JzIiwicHJpb3JpdHkiLCJkZWZhdWx0IiwicmV1c2VFeGlzdGluZ0NodW5rIiwiZ2V0Q29tbW9uIiwiY29udGV4dCIsImRldnRvb2wiLCJ0YXJnZXQiLCJ3YXRjaCIsImV4dGVybmFscyIsImluZnJhc3RydWN0dXJlTG9nZ2luZyIsImxldmVsIiwiYWRkUmVhY3RSZWZyZXNoIiwiZmluYWxPcHRpb25zIiwiYmFiZWxMb2FkZXJDYWNoZU9wdGlvbnMiLCJjYWNoZURpcmVjdG9yeSIsImNhY2hlQ29tcHJlc3Npb24iLCJjb21wYWN0IiwiZGVmYXVsdHMiLCJvdmVycmlkZSIsImVudlZhcmlhYmxlcyIsIm1hdGNoIiwicHJvY2VzcyIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJnZXRBcHBEaXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFJQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFRQTs7QUFJQTs7Ozs7Ozs7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SyxJQUFBQSxNQUFNLENBQUNDLElBQVAsaUJBQVltSyxPQUFPLENBQUMvSyxHQUFwQix1REFBMkIsRUFBM0IsRUFBK0JhLE9BQS9CLENBQXVDQyxHQUFHLElBQUk7QUFDN0MsVUFBSUEsR0FBRyxDQUFDa0ssVUFBSixDQUFlRixLQUFmLENBQUosRUFBMkI7QUFDMUJELFFBQUFBLFlBQVksQ0FBRSxlQUFjL0osR0FBRyxDQUFDbUssU0FBSixDQUFjSCxLQUFLLENBQUNJLE1BQXBCLENBQTRCLEVBQTVDLENBQVosR0FDQ3hKLElBQUksQ0FBQ0MsU0FBTCxDQUFlb0osT0FBTyxDQUFDL0ssR0FBUixDQUFZYyxHQUFaLENBQWYsQ0FERDtBQUVBO0FBQ0QsS0FMRDtBQU1BLFdBQU8rSixZQUFQO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7OztBQUNRTSxFQUFBQSxTQUFTLEdBQVc7QUFDMUIsV0FBTyxLQUFLaEwsTUFBWjtBQUNBOztBQXpwQitCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0YmFiZWxQcmVzZXQsXG5cdFByZXNldE9wdGlvbnMsXG59IGZyb20gJ0B3cGFja2lvL2JhYmVsLXByZXNldC1iYXNlL2xpYi9wcmVzZXQnO1xuaW1wb3J0IHsgQ2xlYW5XZWJwYWNrUGx1Z2luIH0gZnJvbSAnY2xlYW4td2VicGFjay1wbHVnaW4nO1xuXG5pbXBvcnQgTWluaUNzc0V4dHJhY3RQbHVnaW4gZnJvbSAnbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4nO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2x1Z2lmeSBmcm9tICdzbHVnaWZ5JztcbmltcG9ydCBUaW1lRml4UGx1Z2luIGZyb20gJ3RpbWUtZml4LXBsdWdpbic7XG5pbXBvcnQgd2VicGFjayBmcm9tICd3ZWJwYWNrJztcbmltcG9ydCBXZWJwYWNrQXNzZXRzTWFuaWZlc3QgZnJvbSAnd2VicGFjay1hc3NldHMtbWFuaWZlc3QnO1xuaW1wb3J0IFJlYWN0UmVmcmVzaFdlYnBhY2tQbHVnaW4gZnJvbSAnQHBtbW13aC9yZWFjdC1yZWZyZXNoLXdlYnBhY2stcGx1Z2luJztcbmltcG9ydCB7IERlcGVuZGVuY3lFeHRyYWN0aW9uV2VicGFja1BsdWdpbiB9IGZyb20gJy4uL3BsdWdpbnMvRGVwZW5kZW5jeUV4dHJhY3Rpb25XZWJwYWNrUGx1Z2luJztcblxuaW1wb3J0IHsgV2F0Y2hNaXNzaW5nTm9kZU1vZHVsZXNQbHVnaW4gfSBmcm9tICcuLi9kZXYtdXRpbHMnO1xuaW1wb3J0IHsgV3BhY2tpb0Vycm9yIH0gZnJvbSAnLi4vZXJyb3JzL1dwYWNraW9FcnJvcic7XG5pbXBvcnQgeyBnZXRCYWJlbFByZXNldHMsIG92ZXJyaWRlQmFiZWxQcmVzZXRPcHRpb25zIH0gZnJvbSAnLi9iYWJlbENvbmZpZyc7XG5pbXBvcnQge1xuXHRCYW5uZXJDb25maWcsXG5cdEZpbGVDb25maWcsXG5cdFByb2plY3RDb25maWcsXG5cdHdlYnBhY2tMb2FkZXJPcHRpb25zT3ZlcnJpZGUsXG59IGZyb20gJy4vcHJvamVjdC5jb25maWcuZGVmYXVsdCc7XG5pbXBvcnQgeyBTZXJ2ZXJDb25maWcgfSBmcm9tICcuL3NlcnZlci5jb25maWcuZGVmYXVsdCc7XG5pbXBvcnQge1xuXHRnZXRGaWxlTG9hZGVyRm9ySnNBbmRTdHlsZUFzc2V0cyxcblx0Z2V0U3R5bGVMb2FkZXJVc2VzLFxufSBmcm9tICcuL2xvYWRlckhlbHBlcnMnO1xuaW1wb3J0IHsgaGFzVHlwZVNjcmlwdCB9IGZyb20gJy4uL2Rldi11dGlscy9vcHMnO1xuXG5pbnRlcmZhY2UgTm9ybWFsaXplZEVudHJ5IHtcblx0W3g6IHN0cmluZ106IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYnBhY2tDb25maWdIZWxwZXJDb25maWcge1xuXHRhcHBOYW1lOiBQcm9qZWN0Q29uZmlnWydhcHBOYW1lJ107XG5cdHR5cGU6IFByb2plY3RDb25maWdbJ3R5cGUnXTtcblx0c2x1ZzogUHJvamVjdENvbmZpZ1snc2x1ZyddO1xuXHRob3N0OiBTZXJ2ZXJDb25maWdbJ2hvc3QnXTtcblx0cG9ydDogU2VydmVyQ29uZmlnWydwb3J0J107XG5cdG91dHB1dFBhdGg6IFByb2plY3RDb25maWdbJ291dHB1dFBhdGgnXTtcblx0dXNlQmFiZWxDb25maWc6IFByb2plY3RDb25maWdbJ3VzZUJhYmVsQ29uZmlnJ107XG5cdGhhc1JlYWN0OiBQcm9qZWN0Q29uZmlnWydoYXNSZWFjdCddO1xuXHR1c2VSZWFjdEpzeFJ1bnRpbWU6IFByb2plY3RDb25maWdbJ3VzZVJlYWN0SnN4UnVudGltZSddO1xuXHRkaXNhYmxlUmVhY3RSZWZyZXNoOiBQcm9qZWN0Q29uZmlnWydkaXNhYmxlUmVhY3RSZWZyZXNoJ107XG5cdGhhc1Nhc3M6IFByb2plY3RDb25maWdbJ2hhc1Nhc3MnXTtcblx0aGFzRmxvdzogUHJvamVjdENvbmZpZ1snaGFzRmxvdyddO1xuXHRoYXNMZXNzOiBQcm9qZWN0Q29uZmlnWydoYXNMZXNzJ107XG5cdGpzQmFiZWxQcmVzZXRPcHRpb25zPzogUHJvamVjdENvbmZpZ1snanNCYWJlbFByZXNldE9wdGlvbnMnXTtcblx0dHNCYWJlbFByZXNldE9wdGlvbnM/OiBQcm9qZWN0Q29uZmlnWyd0c0JhYmVsUHJlc2V0T3B0aW9ucyddO1xuXHRqc0JhYmVsT3ZlcnJpZGU/OiBQcm9qZWN0Q29uZmlnWydqc0JhYmVsT3ZlcnJpZGUnXTtcblx0dHNCYWJlbE92ZXJyaWRlPzogUHJvamVjdENvbmZpZ1sndHNCYWJlbE92ZXJyaWRlJ107XG5cdGJhbm5lckNvbmZpZzogQmFubmVyQ29uZmlnO1xuXHRhbGlhcz86IFByb2plY3RDb25maWdbJ2FsaWFzJ107XG5cdG9wdGltaXplU3BsaXRDaHVua3M6IFByb2plY3RDb25maWdbJ29wdGltaXplU3BsaXRDaHVua3MnXTtcblx0cHVibGljUGF0aDogc3RyaW5nOyAvLyBOb3QgdXNlZCByaWdodCBub3csIGJ1dCBtYXliZSB3ZSB3aWxsIG5lZWQgaXQgaW4gZnV0dXJlP1xuXHRwdWJsaWNQYXRoVXJsOiBzdHJpbmc7XG5cdGVycm9yT3ZlcmxheTogUHJvamVjdENvbmZpZ1snZXJyb3JPdmVybGF5J107XG5cdGV4dGVybmFsczogUHJvamVjdENvbmZpZ1snZXh0ZXJuYWxzJ107XG5cdC8vIHdoZXRoZXIgb3Igbm90IHRvIGRpc2FibGUgd29yZHByZXNzIGV4dGVybmFsIHNjcmlwdHMgaGFuZGxpbmdcblx0ZGlzYWJsZVdvcmRQcmVzc0V4dGVybmFscz86IGJvb2xlYW47XG5cdGNvbXBpbGVOb2RlTW9kdWxlczoge1xuXHRcdGRldjogYm9vbGVhbjtcblx0XHRwcm9kOiBib29sZWFuO1xuXHR9O1xufVxuXG5pbnRlcmZhY2UgQ29tbW9uV2VicGFja0NvbmZpZyB7XG5cdGNvbnRleHQ6IHdlYnBhY2suQ29uZmlndXJhdGlvblsnY29udGV4dCddO1xuXHRkZXZ0b29sOiB3ZWJwYWNrLkNvbmZpZ3VyYXRpb25bJ2RldnRvb2wnXTtcblx0dGFyZ2V0OiB3ZWJwYWNrLkNvbmZpZ3VyYXRpb25bJ3RhcmdldCddO1xuXHR3YXRjaDogd2VicGFjay5Db25maWd1cmF0aW9uWyd3YXRjaCddO1xuXHRtb2RlOiB3ZWJwYWNrLkNvbmZpZ3VyYXRpb25bJ21vZGUnXTtcblx0bmFtZTogd2VicGFjay5Db25maWd1cmF0aW9uWyduYW1lJ107XG5cdGV4dGVybmFsczogd2VicGFjay5Db25maWd1cmF0aW9uWydleHRlcm5hbHMnXTtcblx0aW5mcmFzdHJ1Y3R1cmVMb2dnaW5nOiBhbnk7XG59XG5cbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdG8gZ2V0IGRpZmZlcmVudCBjb25maWd1cmF0aW9uIG9mIHdlYnBhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJwYWNrQ29uZmlnSGVscGVyIHtcblx0Ly8gVGhpcyBpcyB3aGVyZSBhbGwgdGhlIGZpbGVuYW1lIHdpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIGNyZWF0ZSBhIGRpcmVjdG9yeVxuXHRwdWJsaWMgcmVhZG9ubHkgYXBwRGlyOiBzdHJpbmc7XG5cblx0Ly8gQWN0dWFsIG91dHB1dFBhdGggYXMgcHJvdmlkZWQgYnkgdXNlclxuXHRwdWJsaWMgcmVhZG9ubHkgb3V0cHV0UGF0aDogc3RyaW5nO1xuXG5cdHByaXZhdGUgZmlsZTogRmlsZUNvbmZpZztcblxuXHRwcml2YXRlIGlzRGV2OiBib29sZWFuO1xuXG5cdHByaXZhdGUgY29uZmlnOiBXZWJwYWNrQ29uZmlnSGVscGVyQ29uZmlnO1xuXG5cdC8qKlxuXHQgKiBDb250ZXh0IGRpcmVjdG9yeSwgZnJvbSB3aGVyZSB3ZSByZWFkIHRoZSBzdHVmZiBhbmQgcHV0IHN0dWZmLlxuXHQgKi9cblx0cHJpdmF0ZSBjd2Q6IHN0cmluZztcblxuXHQvKipcblx0ICogU2ltdWxhdGVkIE5PREVfRU5WIHN0cmluZywgdXNlZCBpbnRlcm5hbGx5IGFuZCBkZWZpbmVkXG5cdCAqIGluIHdlYnBhY2sgd2l0aCB3ZWJwYWNrLkRlZmluZVBsdWdpbi5cblx0ICovXG5cdHByaXZhdGUgZW52OiAnZGV2ZWxvcG1lbnQnIHwgJ3Byb2R1Y3Rpb24nO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgR2V0RW50cnlBbmRPdXRwdXQgY2xhc3MuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihcblx0XHRmaWxlOiBGaWxlQ29uZmlnLFxuXHRcdGNvbmZpZzogV2VicGFja0NvbmZpZ0hlbHBlckNvbmZpZyxcblx0XHRjd2Q6IHN0cmluZyxcblx0XHRpc0RldjogYm9vbGVhbiA9IHRydWVcblx0KSB7XG5cdFx0dGhpcy5maWxlID0gZmlsZTtcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcblx0XHR0aGlzLmN3ZCA9IGN3ZDtcblx0XHR0aGlzLmlzRGV2ID0gaXNEZXY7XG5cdFx0aWYgKGlzRGV2KSB7XG5cdFx0XHR0aGlzLmVudiA9ICdkZXZlbG9wbWVudCc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZW52ID0gJ3Byb2R1Y3Rpb24nO1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSB0aGUgb3V0cHV0UGF0aCwgYmVjYXVzZSB3ZSB3b3VsZCBiZSBuZWVkaW5nIHRoYXRcblx0XHRjb25zdCB7IG91dHB1dFBhdGggfSA9IHRoaXMuY29uZmlnO1xuXHRcdC8vIGFuZCBmaWxlbmFtZSBhbmQgaW5uZXIgZGlyZWN0b3J5IG5hbWVcblx0XHQvLyB0aGlzIGlubmVyRGlyIHdpbGwgYmUgcHJlZml4ZWQgdG8gYWxsIGZpbGVuYW1lXG5cdFx0Ly8gYmVjYXVzZSBmb3IgbXVsdGktY29tcGlsZXIgdG8gd29yaywgd2UgbmVlZFxuXHRcdC8vIG91dHB1dFBhdGggYW5kIHB1YmxpY1BhdGggdGhlbXNlbHZlcyBvbiB0aGUgc2FtZSBwYXRoLlxuXHRcdC8vIGFsbCBtaWRkbGV3YXJlcyB3b3VsZCBhY3R1YWxseSB1c2UgdGhlIGBuYW1lYCBmcm9tIHdlYnBhY2sgY29uZmlnXG5cdFx0Ly8gdG8gc2VwYXJhdGUgdXBkYXRlcy5cblx0XHRjb25zdCB7IG5hbWUgfSA9IHRoaXMuZmlsZTtcblx0XHR0aGlzLmFwcERpciA9IHNsdWdpZnkobmFtZSwgeyBsb3dlcjogdHJ1ZSB9KTtcblx0XHR0aGlzLm91dHB1dFBhdGggPSBwYXRoLmpvaW4odGhpcy5jd2QsIG91dHB1dFBhdGgpO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBnZXRIbXJQYXRoKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIGAvX193cGFja2lvX2htcmA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHdlYnBhY2sgY29tcGF0aWJsZSBlbnRyeSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBUaGUgZW50cnkgb2JqZWN0IGhhcyBtZW1iZXJzIHdoaWNoIGFsd2F5cyBoYXMgc3RyaW5nW10uXG5cdCAqIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgd2UgY2FuIGluc2VydCB0aGUgaG90IGxvYWRlciBjbGllbnRcblx0ICogd2hlbiBuZWNlc3NhcnkuXG5cdCAqL1xuXHRwdWJsaWMgZ2V0RW50cnkoKTogTm9ybWFsaXplZEVudHJ5IHtcblx0XHQvLyBGaXJzdCBkZXN0cnVjdHVyZSBhd2F5IHRoZSBzdHVmZiB3ZSBuZWVkXG5cdFx0Y29uc3QgeyBuYW1lLCBlbnRyeSB9ID0gdGhpcy5maWxlO1xuXHRcdC8vIFdlIGludGVuZCB0byBwYXNzIHRoZSBlbnRyeSBkaXJlY3RseSB0byB3ZWJwYWNrLFxuXHRcdC8vIGJ1dCwgd2UgbmVlZCB0byBhZGQgdGhlIGhvdC1taWRkbGV3YXJlIGNsaWVudCB0byB0aGUgZW50cnlcblx0XHQvLyBlbHNlIGl0IHdpbGwgc2ltcGx5IG5vdCB3b3JrXG5cdFx0Y29uc3Qgbm9ybWFsaXplZEVudHJ5OiBOb3JtYWxpemVkRW50cnkgPSB7fTtcblx0XHQvLyBMb29wIG92ZXIgYWxsIHVzZXIgZGVmaW5lZCBlbnRyaWVzIGFuZCBhZGQgdG8gdGhlIG5vcm1hbGl6ZWRFbnRyeVxuXHRcdE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xuXHRcdFx0Ly8gV2UgaGF2ZSB0byBicmVhayBhbmQgdGFrZSB0aGUgdmFsdWUgaW4gYSBzZXBhcmF0ZVxuXHRcdFx0Ly8gdmFyaWFibGUsIG90aGVyd2lzZSB0eXBlc2NyaXB0IHNheXMgYWxsIHRoZSB3ZWlyZFxuXHRcdFx0Ly8gdGhpbmcg8J+YolxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMDQ0MiNpc3N1ZWNvbW1lbnQtNDI2MjAzODYzXG5cdFx0XHRjb25zdCBlbnRyeVBvaW50OiBzdHJpbmdbXSB8IHN0cmluZyA9IGVudHJ5W2tleV07XG5cdFx0XHRub3JtYWxpemVkRW50cnlba2V5XSA9IEFycmF5LmlzQXJyYXkoZW50cnlQb2ludClcblx0XHRcdFx0PyAvLyBtYXliZSB3ZSBjYW4gZ28gYSBzdGVwIGZ1dGhlciBhbmQgcHV0IGFuIGVudHJ5IHBvaW50IHdoaWNoIHRha2VzXG5cdFx0XHRcdCAgLy8gY2FyZSBvZiB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0XHRcdFx0ICAvLyBsaWtlIGBAd3BhY2tpby9wdWJsaWNwYXRoP291dHB1dFBhdGg9JHt0aGlzLmNvbmZpZy5vdXRwdXRQYXRofSZhcHBOYW1lPSR7dGhpcy5jb25maWcuYXBwTmFtZX1gXG5cdFx0XHRcdCAgZW50cnlQb2ludFxuXHRcdFx0XHQ6IFtlbnRyeVBvaW50XTtcblx0XHR9KTtcblx0XHQvLyBOb3csIGlmIGluIGRldiBtb2RlLCB0aGVuIGFkZCB0aGUgaG90IG1pZGRsZXdhcmUgY2xpZW50XG5cdFx0aWYgKHRoaXMuaXNEZXYpIHtcblx0XHRcdC8vIFdoZXRoZXIgb3Igbm90IHdlIHVzZSB0aGUgcmVhY3QtcmVmcmVzaCBhbmQgZmFtaWx5LCB3ZSBuZWVkIHRoZSBkZWZhdWx0XG5cdFx0XHQvLyB3aG0gY2xpZW50IGZvciB0aGlzIHRvIHdvcmsuXG5cdFx0XHQvLyBDdXN0b20gb3ZlcmxheSBhbmQgaXQncyBzdHlsaW5nXG5cdFx0XHQvLyBDdXN0b20gc3R5bGVcblx0XHRcdGNvbnN0IG92ZXJsYXlTdHlsZXM6IG9iamVjdCA9IHtcblx0XHRcdFx0ekluZGV4OiA5OTk5OTk5OTksXG5cdFx0XHRcdGZvbnRTaXplOiAnMTRweCcsXG5cdFx0XHRcdGZvbnRGYW1pbHk6XG5cdFx0XHRcdFx0J0RhbmsgTW9ubywgT3BlcmF0b3IgTW9ubyBTU20sIE9wZXJhdG9yIE1vbm8sIE1lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJyxcblx0XHRcdFx0cGFkZGluZzogJzMycHggMTZweCcsXG5cdFx0XHR9O1xuXHRcdFx0Ly8gRGVmaW5lIHRoZSBob3QgY2xpZW50IHN0cmluZ1xuXHRcdFx0Ly9cblx0XHRcdC8vIEhlcmUgd2UgbmVlZFxuXHRcdFx0Ly8gMS4gY2xpZW50IC0gYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBjb25zaXN0ZW50IGFjcm9zcyB0aGlzIGFuZCBXSE0uXG5cdFx0XHQvLyAyLiBvdmVybGF5IGFuZCBvdmVybGF5U3R5cGVzIC0gVG8gZW5hYmxlIG92ZXJsYXkgb24gZXJyb3JzLCB3ZSBkb24ndCBuZWVkIHdhcm5pbmdzIGhlcmVcblx0XHRcdC8vIDMuIHBhdGggLSBUaGUgb3V0cHV0IHBhdGgsIFdlIG5lZWQgdG8gbWFrZSBzdXJlIGJvdGggc2VydmVyIGFuZCBjbGllbnQgaGFzIHRoZSBzYW1lIHZhbHVlLlxuXHRcdFx0Ly8gNC4gbmFtZSAtIEJlY2F1c2UgaXQgY291bGQgYmUgbXVsdGljb21waWxlclxuXHRcdFx0Y29uc3Qgd2VicGFja0hvdENsaWVudDogc3RyaW5nID0gYHdlYnBhY2staG90LW1pZGRsZXdhcmUvY2xpZW50P3BhdGg9JHtXZWJwYWNrQ29uZmlnSGVscGVyLmdldEhtclBhdGgoKX0mbmFtZT0ke25hbWV9JHtcblx0XHRcdFx0dGhpcy5jb25maWcuZXJyb3JPdmVybGF5ID8gJyZvdmVybGF5PXRydWUnIDogJydcblx0XHRcdH0mcmVsb2FkPXRydWUmb3ZlcmxheVN0eWxlcz0ke2VuY29kZVVSSUNvbXBvbmVudChcblx0XHRcdFx0SlNPTi5zdHJpbmdpZnkob3ZlcmxheVN0eWxlcylcblx0XHRcdCl9YDtcblxuXHRcdFx0Ly8gTm93IGFkZCB0byBlYWNoIG9mIHRoZSBlbnRyaWVzXG5cdFx0XHQvLyBXZSBkb24ndCBrbm93IGlmIHVzZXIgd2FudCB0byBzcGVjaWZpY2FsbHkgZGlzYWJsZSBmb3Igc29tZSwgYnV0IGxldCdzXG5cdFx0XHQvLyBub3QgdGhpbmsgYWhlYWQgb2Ygb3Vyc2VsdmVzXG5cdFx0XHRPYmplY3Qua2V5cyhub3JtYWxpemVkRW50cnkpLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRFbnRyeVtrZXldID0gW1xuXHRcdFx0XHRcdC8vIHB1dCB3ZWJwYWNrIGhvdCBjbGllbnQgaW4gdGhlIGVudHJ5IGF0IHRoZSB0b3Bcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UgSE1SIHdpbGwgc3RvcCB3b3JraW5nIGFmdGVyIGFuIHVwZGF0ZVxuXHRcdFx0XHRcdHdlYnBhY2tIb3RDbGllbnQsXG5cdFx0XHRcdFx0Li4ubm9ybWFsaXplZEVudHJ5W2tleV0sXG5cdFx0XHRcdF07XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gUHV0IHRoZSBwdWJsaWNQYXRoIGVudHJ5IHBvaW50XG5cdFx0XHRPYmplY3Qua2V5cyhub3JtYWxpemVkRW50cnkpLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRFbnRyeVtrZXldID0gW1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgaXQgYmVmb3JlIGFueSBvdGhlciBlbnRyeXBvaW50LCBvdGhlcndpc2UgaXQgd29uJ3Rcblx0XHRcdFx0XHQvLyB3b3JrLCBpZiBFUyBNb2R1bGVzIGFyZSB1c2VkLlxuXHRcdFx0XHRcdGBAd3BhY2tpby9lbnRyeXBvaW50L2xpYi9pbmRleGAsXG5cdFx0XHRcdFx0Li4ubm9ybWFsaXplZEVudHJ5W2tleV0sXG5cdFx0XHRcdF07XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbm9ybWFsaXplZEVudHJ5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB3ZWJwYWNrIGNvbXBhdGlibGUgb3V0cHV0IG9iamVjdC5cblx0ICovXG5cdHB1YmxpYyBnZXRPdXRwdXQoKTogd2VicGFjay5PdXRwdXQge1xuXHRcdC8vIEFzc3VtaW5nIGl0IGlzIHByb2R1Y3Rpb25cblx0XHRjb25zdCBvdXRwdXQ6IHdlYnBhY2suT3V0cHV0ID0ge1xuXHRcdFx0Ly8gSGVyZSB3ZSBjcmVhdGUgYSBkaXJlY3RvcnkgaW5zaWRlIHRoZSB1c2VyIHByb3ZpZGVkIG91dHB1dFBhdGhcblx0XHRcdC8vIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaXMgdGhlIHNsdWdnaWZpZWQgdmVyaW9uIG9mIGBuYW1lYFxuXHRcdFx0Ly8gb2YgdGhpcyBjb25maWd1cmF0aW9uIG9iamVjdC5cblx0XHRcdC8vIEFsc28gaGVyZSB3ZSBhc3N1bWUsIHVzZXIgaGFzIHBhc3NlZCBpbiB0aGUgY29ycmVjdCBgcmVsYXRpdmVgXG5cdFx0XHQvLyBwYXRoIGZvciBgb3V0cHV0UGF0aGAuIE90aGVyd2lzZSB0aGlzIHdpbGwgYnJlYWsuXG5cdFx0XHQvLyBXZSBkbyBub3QgdXNlIHBhdGgucmVzb2x2ZSwgYmVjYXVzZSB3ZSBleHBlY3Qgb3V0cHV0UGF0aCB0byBiZVxuXHRcdFx0Ly8gcmVsYXRpdmUuIEB0b2RvOiBjcmVhdGUgYSB0ZXN0IGhlcmVcblx0XHRcdHBhdGg6IHRoaXMub3V0cHV0UGF0aCxcblx0XHRcdGZpbGVuYW1lOiBgJHt0aGlzLmFwcERpcn0vJHtcblx0XHRcdFx0dGhpcy5pc0RldiA/ICdbbmFtZV0nIDogJ1tuYW1lXS1bY29udGVudGhhc2g6OF0nXG5cdFx0XHR9LmpzYCxcblx0XHRcdC8vIGxlYXZlIGJsYW5rIGJlY2F1c2Ugd2Ugd291bGQgaGFuZGxlIHdpdGggZnJlZSB2YXJpYWJsZVxuXHRcdFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gaW4gcnVudGltZS5cblx0XHRcdHB1YmxpY1BhdGg6ICcnLFxuXHRcdFx0Ly8gd2UgbmVlZCBkaWZmZXJlbnQganNvbnBGdW5jdGlvbiwgaXQgaGFzIHRvXG5cdFx0XHQvLyBiZSB1bmlxdWUgZm9yIGV2ZXJ5IHdlYnBhY2sgY29uZmlnLCBvdGhlcndpc2Vcblx0XHRcdC8vIHRoZSBsYXRlciB3aWxsIG92ZXJyaWRlIHRoZSBwcmV2aW91c1xuXHRcdFx0Ly8gaGF2aW5nIGNvbWJpbmF0aW9uIG9mIGFwcE5hbWUgYW5kIGZpbGUubmFtZVxuXHRcdFx0Ly8ga2luZCBvZiBlbnN1cmVzIHRoYXQgYmlsbGlvbnMgb2YgZGV2cywgZG9uJ3Rcblx0XHRcdC8vIG92ZXJyaWRlIGVhY2ggb3RoZXIhISEhXG5cdFx0XHRqc29ucEZ1bmN0aW9uOiBgd3BhY2tpbyR7dGhpcy5jb25maWcuYXBwTmFtZX0ke3RoaXMuZmlsZS5uYW1lfUpzb25wYCxcblx0XHR9O1xuXHRcdC8vIEFkZCB0aGUgcHVibGljUGF0aCBpZiBpdCBpcyBpbiBkZXZNb2RlXG5cdFx0aWYgKHRoaXMuaXNEZXYpIHtcblx0XHRcdC8vIFRoaXMgaXMgY2FsY3VsYXRlZCBieSBDcmVhdGVXZWJwYWNrQ29uZmlnXG5cdFx0XHQvLyB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHVzZXIncyBvd24gdmFsdWUuXG5cdFx0XHQvLyBTbywgaWYgV29yZFByZXNzIGRlZmF1bHRzIGFyZSBjaGFuZ2VkLCB0aGVuXG5cdFx0XHQvLyBkZXBlbmRpbmcgb24gd3BhY2tpby5zZXJ2ZXIuanMsIGl0IHdpbGwgc3RpbGxcblx0XHRcdC8vIHBvaW50IHRvIHRoZSByaWdodCBsb2NhdGlvbi4gSXQgb25seSBtYWtlc1xuXHRcdFx0Ly8gZHluYW1pYyBpbXBvcnQgYW5kIHNvbWUgb24tZGVtYW5kIHNwbGl0LWNodW5rXG5cdFx0XHQvLyB3b3JrLlxuXHRcdFx0b3V0cHV0LnB1YmxpY1BhdGggPSB0aGlzLmNvbmZpZy5wdWJsaWNQYXRoVXJsO1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IFdlYlBhY2sgcGx1Z2lucywgZGVwZW5kaW5nIG9uIGRldmVsb3BtZW50IG9yIHByb2R1Y3Rpb25cblx0ICovXG5cdHB1YmxpYyBnZXRQbHVnaW5zKCk6IHdlYnBhY2suUGx1Z2luW10ge1xuXHRcdC8vIEFkZCBjb21tb24gcGx1Z2luc1xuXHRcdGxldCBwbHVnaW5zOiB3ZWJwYWNrLlBsdWdpbltdID0gW1xuXHRcdFx0Ly8gRGVmaW5lIGVudlxuXHRcdFx0bmV3IHdlYnBhY2suRGVmaW5lUGx1Z2luKHtcblx0XHRcdFx0J3Byb2Nlc3MuZW52Lk5PREVfRU5WJzogSlNPTi5zdHJpbmdpZnkodGhpcy5lbnYpLFxuXHRcdFx0XHQncHJvY2Vzcy5lbnYuQkFCRUxfRU5WJzogSlNPTi5zdHJpbmdpZnkodGhpcy5lbnYpLFxuXHRcdFx0XHQuLi50aGlzLmdldEVudlZhcmlhYmxlcygpLFxuXHRcdFx0XHQvLyBPdXIgb3duIGFjY2VzcyB0byBwcm9qZWN0IGNvbmZpZyBmcm9tIHRoZSBtb2R1bGVzXG5cdFx0XHRcdC8vIG1haW5seSBuZWVkZWQgZm9yIHRoZSBwdWJsaWNQYXRoIGVudHJ5cG9pbnRcblx0XHRcdFx0X19XUEFDS0lPX186IHtcblx0XHRcdFx0XHRhcHBOYW1lOiBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZy5hcHBOYW1lKSxcblx0XHRcdFx0XHRvdXRwdXRQYXRoOiBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZy5vdXRwdXRQYXRoKSxcblx0XHRcdFx0fSxcblx0XHRcdH0pLFxuXHRcdFx0Ly8gQ2xlYW4gZGlzdCBkaXJlY3Rvcnlcblx0XHRcdG5ldyBDbGVhbldlYnBhY2tQbHVnaW4oe1xuXHRcdFx0XHR2ZXJib3NlOiBmYWxzZSxcblx0XHRcdFx0Y2xlYW5PbmNlQmVmb3JlQnVpbGRQYXR0ZXJuczogW2Ake3RoaXMub3V0cHV0UGF0aH0vJHt0aGlzLmFwcERpcn1gXSxcblx0XHRcdH0pIGFzIHVua25vd24gYXMgd2VicGFjay5QbHVnaW4sXG5cdFx0XHQvLyBJbml0aWF0ZSBtaW5pIGNzcyBleHRyYWN0XG5cdFx0XHRuZXcgTWluaUNzc0V4dHJhY3RQbHVnaW4oe1xuXHRcdFx0XHRmaWxlbmFtZTogYCR7dGhpcy5hcHBEaXJ9LyR7XG5cdFx0XHRcdFx0dGhpcy5pc0RldiA/ICdbbmFtZV0nIDogJ1tuYW1lXS1bY29udGVudGhhc2g6OF0nXG5cdFx0XHRcdH0uY3NzYCwgLy8gd2UgZG8gaXQgdGhpcyB3YXksIHNvIHRoYXQgd2UgY2FuIGVhc2lseSBzZXR1cCBlMmUgdGVzdHMsIHdlIGNhbiBhbHdheXMgcHJlZGljdCB3aGF0IHRoZSBuYW1lIHdvdWxkIGJlXG5cdFx0XHRcdGlnbm9yZU9yZGVyOiBmYWxzZSxcblx0XHRcdH0pLFxuXHRcdFx0Ly8gQ3JlYXRlIE1hbmlmZXN0IGZvciBQSFAgQ29uc3VtcHRpb25cblx0XHRcdG5ldyBXZWJwYWNrQXNzZXRzTWFuaWZlc3Qoe1xuXHRcdFx0XHR3cml0ZVRvRGlzazogdHJ1ZSxcblx0XHRcdFx0b3V0cHV0OiBgJHt0aGlzLm91dHB1dFBhdGh9LyR7dGhpcy5hcHBEaXJ9L21hbmlmZXN0Lmpzb25gLFxuXHRcdFx0XHRwdWJsaWNQYXRoOiBgYCwgLy8gV2UgZG9udCBwdXQgJHt0aGlzLmNvbmZpZy5vdXRwdXRQYXRofS8gaGVyZSBiZWNhdXNlLCBQSFAgd2lsbCBwaWNrIGl0IHVwIGFueXdheS5cblx0XHRcdFx0ZW50cnlwb2ludHM6IHRydWUsXG5cdFx0XHRcdGVudHJ5cG9pbnRzS2V5OiAnd3BhY2tpb0VwJyxcblx0XHRcdH0pIGFzIHVua25vd24gYXMgd2VicGFjay5QbHVnaW4sXG5cdFx0XTtcblx0XHQvLyBBZGQgdHMgY2hlY2tlciBwbHVnaW4gaWYgcHJvamVjdCBoYXMgdHNjb25maWcuanNvblxuXHRcdGNvbnN0IFtpc1RzLCB0c2NvbmZpZ1BhdGhdID0gaGFzVHlwZVNjcmlwdCh0aGlzLmN3ZCk7XG5cdFx0aWYgKGlzVHMgJiYgdGhpcy5maWxlLmhhc1R5cGVTY3JpcHQgIT09IGZhbHNlKSB7XG5cdFx0XHQvLyBkeW5hbWljIHJlcXVpcmUgZm9ya3RzY2hlY2tlciBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBlcnJvclxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgZ2xvYmFsLXJlcXVpcmUsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcblx0XHRcdFx0Y29uc3QgRm9ya1RzQ2hlY2tlcldlYnBhY2tQbHVnaW4gPSByZXF1aXJlKCdmb3JrLXRzLWNoZWNrZXItd2VicGFjay1wbHVnaW4nKTtcblx0XHRcdFx0cGx1Z2lucy5wdXNoKFxuXHRcdFx0XHRcdG5ldyBGb3JrVHNDaGVja2VyV2VicGFja1BsdWdpbih7XG5cdFx0XHRcdFx0XHRhc3luYzogdGhpcy5pc0Rldixcblx0XHRcdFx0XHRcdHR5cGVzY3JpcHQ6IHtcblx0XHRcdFx0XHRcdFx0Y29uZmlnRmlsZTogdHNjb25maWdQYXRoLFxuXHRcdFx0XHRcdFx0XHRtb2RlOiAnd3JpdGUtcmVmZXJlbmNlcycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXNsaW50OiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRmb3JtYXR0ZXI6ICdjb2RlZnJhbWUnLFxuXHRcdFx0XHRcdFx0bG9nZ2VyOiB7XG5cdFx0XHRcdFx0XHRcdGluZnJhc3RydWN0dXJlOiAnc2lsZW50Jyxcblx0XHRcdFx0XHRcdFx0aXNzdWVzOiAnc2lsZW50Jyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFdwYWNraW9FcnJvcihlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgd29yZHByZXNzIGRlcGVuZGVuY3kgZXh0cmFjdCBwbHVnaW5cblx0XHRpZiAodGhpcy5jb25maWcuZGlzYWJsZVdvcmRQcmVzc0V4dGVybmFscyAhPT0gdHJ1ZSkge1xuXHRcdFx0cGx1Z2lucy5wdXNoKFxuXHRcdFx0XHRuZXcgRGVwZW5kZW5jeUV4dHJhY3Rpb25XZWJwYWNrUGx1Z2luKHtcblx0XHRcdFx0XHRndXRlbmJlcmdPcHRpbWl6ZWQ6IHRoaXMuZmlsZS5vcHRpbWl6ZUZvckd1dGVuYmVyZyA/PyBmYWxzZSxcblx0XHRcdFx0XHRhcHBEaXI6IHRoaXMuYXBwRGlyLFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBBZGQgZGV2ZWxvcG1lbnQgc3BlY2lmaWMgcGx1Z2luc1xuXHRcdGlmICh0aGlzLmlzRGV2KSB7XG5cdFx0XHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5cdFx0XHRwbHVnaW5zLnB1c2gobmV3IHdlYnBhY2suSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4oKSk7XG5cdFx0XHQvLyBJZiB5b3UgcmVxdWlyZSBhIG1pc3NpbmcgbW9kdWxlIGFuZCB0aGVuIGBucG0gaW5zdGFsbGAgaXQsIHlvdSBzdGlsbCBoYXZlXG5cdFx0XHQvLyB0byByZXN0YXJ0IHRoZSBkZXZlbG9wbWVudCBzZXJ2ZXIgZm9yIFdlYnBhY2sgdG8gZGlzY292ZXIgaXQuIFRoaXMgcGx1Z2luXG5cdFx0XHQvLyBtYWtlcyB0aGUgZGlzY292ZXJ5IGF1dG9tYXRpYyBzbyB5b3UgZG9uJ3QgaGF2ZSB0byByZXN0YXJ0LlxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8xODZcblx0XHRcdHBsdWdpbnMucHVzaChcblx0XHRcdFx0bmV3IFdhdGNoTWlzc2luZ05vZGVNb2R1bGVzUGx1Z2luKFxuXHRcdFx0XHRcdHBhdGgucmVzb2x2ZSh0aGlzLmN3ZCwgJy4vbm9kZV9tb2R1bGVzJylcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHRcdC8vIEFkZCB0aW1ld2F0Y2ggcGx1Z2luIHRvIGF2b2lkIG11bHRpcGxlIHN1Y2Nlc3NpdmUgYnVpbGRcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dhdGNocGFjay9pc3N1ZXMvMjVcblx0XHRcdHBsdWdpbnMgPSBbbmV3IFRpbWVGaXhQbHVnaW4oKSwgLi4ucGx1Z2luc107XG5cblx0XHRcdC8vIEFkZCByZWFjdCByZWZyZXNoIGlmIG5lZWRlZFxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLmNvbmZpZy5oYXNSZWFjdCAmJlxuXHRcdFx0XHQhdGhpcy5jb25maWcuZGlzYWJsZVJlYWN0UmVmcmVzaCAmJlxuXHRcdFx0XHQhdGhpcy5maWxlLm9wdGltaXplRm9yR3V0ZW5iZXJnXG5cdFx0XHQpIHtcblx0XHRcdFx0cGx1Z2lucy5wdXNoKFxuXHRcdFx0XHRcdG5ldyBSZWFjdFJlZnJlc2hXZWJwYWNrUGx1Z2luKHtcblx0XHRcdFx0XHRcdG92ZXJsYXk6IHtcblx0XHRcdFx0XHRcdFx0c29ja0ludGVncmF0aW9uOiAnd2htJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWRkIFByb2R1Y3Rpb24gc3BlY2lmaWMgcGx1Z2luc1xuXHRcdFx0Y29uc3QgeyBiYW5uZXJDb25maWcgfSA9IHRoaXMuY29uZmlnO1xuXHRcdFx0Y29uc3QgY3JlZGl0Tm90ZSA9XG5cdFx0XHRcdCdcXG5cXG5Db21waWxlZCB3aXRoIHRoZSBoZWxwIG9mIGh0dHBzOi8vd3BhY2suaW9cXG5BIHplcm8gc2V0dXAgV2VicGFjayBCdW5kbGVyIFNjcmlwdCBmb3IgV29yZFByZXNzJztcblx0XHRcdHBsdWdpbnMucHVzaChcblx0XHRcdFx0Ly8gQmFubmVyIHBsdWdpblxuXHRcdFx0XHRuZXcgd2VicGFjay5CYW5uZXJQbHVnaW4oe1xuXHRcdFx0XHRcdGVudHJ5T25seTogZmFsc2UsXG5cdFx0XHRcdFx0cmF3OiBmYWxzZSxcblx0XHRcdFx0XHQvLyBBZGQgdG8gdHMsIHRzeCwgY3NzLCBzY3NzLCBzYXNzXG5cdFx0XHRcdFx0aW5jbHVkZTogL1xcLigodHxqKXN4P3xzPyhjfGEpc3MpJC8sXG5cdFx0XHRcdFx0YmFubmVyOiBgXG4ke2Jhbm5lckNvbmZpZy5uYW1lfVxuXG5AYXV0aG9yICR7YmFubmVyQ29uZmlnLmF1dGhvcn1cbkB2ZXJzaW9uICR7YmFubmVyQ29uZmlnLnZlcnNpb259XG5AbGluayAke2Jhbm5lckNvbmZpZy5saW5rfVxuQGxpY2Vuc2UgJHtiYW5uZXJDb25maWcubGljZW5zZX1cblxuQ29weXJpZ2h0IChjKSAke25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX0gJHtiYW5uZXJDb25maWcuYXV0aG9yfVxuXG4ke2Jhbm5lckNvbmZpZy5jb3B5cmlnaHRUZXh0fSR7YmFubmVyQ29uZmlnLmNyZWRpdCA/IGNyZWRpdE5vdGUgOiAnJ31gLFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gaXRcblx0XHRyZXR1cm4gcGx1Z2lucztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgbW9kdWxlIG9iamVjdCBmb3Igd2VicGFjaywgZGVwZW5kaW5nIG9uIGVudmlyb25tZW50LlxuXHQgKi9cblx0cHVibGljIGdldE1vZHVsZSgpOiB3ZWJwYWNrLk1vZHVsZSB7XG5cdFx0Y29uc3QgeyBoYXNSZWFjdCwgaGFzU2FzcywgaGFzRmxvdywgaGFzTGVzcyB9ID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3Qgd3BhY2tpb0JhYmVsT3B0aW9uczogUHJlc2V0T3B0aW9ucyA9IHtcblx0XHRcdGhhc1JlYWN0LFxuXHRcdFx0Ly8gdXNlIHJlYWN0IGpzeCBydW50aW1lIG9ubHkgaWYgZW5hYmxlZCBleHBsaWNpdGx5XG5cdFx0XHQvLyBhbmQgbm90IG9wdGltaXppbmcgZm9yIGd1dGVuYmVyZ1xuXHRcdFx0dXNlUmVhY3RKc3hSdW50aW1lOlxuXHRcdFx0XHR0aGlzLmNvbmZpZy51c2VSZWFjdEpzeFJ1bnRpbWUgJiYgIXRoaXMuZmlsZS5vcHRpbWl6ZUZvckd1dGVuYmVyZyxcblx0XHR9O1xuXG5cdFx0Ly8gY2hlY2sgaWYgYmFiZWwuY29uZmlnLmpzIGlzIHByZXNlbnRcblx0XHRjb25zdCBpc0JhYmVsQ29uZmlnUHJlc2VudCA9IHRoaXMuY29uZmlnLnVzZUJhYmVsQ29uZmlnO1xuXG5cdFx0Ly8gUHVzaCB0YXJnZXRzIHRvIGJhYmVsLXByZXNldC1lbnYgaWYgdGhpcyBpcyBkZXZcblx0XHQvLyBXZSB0YXJnZXQgb25seSB0aGUgbGF0ZXN0IGNocm9tZSBhbmQgZmlyZWZveCBmb3Jcblx0XHQvLyBncmVhdGVyIHNwZWVkXG5cdFx0aWYgKHRoaXMuaXNEZXYpIHtcblx0XHRcdHdwYWNraW9CYWJlbE9wdGlvbnMucHJlc2V0RW52ID0ge1xuXHRcdFx0XHR0YXJnZXRzOiB7XG5cdFx0XHRcdFx0Y2hyb21lOiAnNjknLFxuXHRcdFx0XHRcdGZpcmVmb3g6ICc2MicsXG5cdFx0XHRcdFx0ZWRnZTogJzE3Jyxcblx0XHRcdFx0fSxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHRoZSBiYWJlbCBydWxlcyBmb3IgZXM2KyBjb2RlXG5cdFx0Y29uc3QganNQcmVzZXRzOiBiYWJlbFByZXNldFtdID0gZ2V0QmFiZWxQcmVzZXRzKFxuXHRcdFx0b3ZlcnJpZGVCYWJlbFByZXNldE9wdGlvbnMoXG5cdFx0XHRcdHdwYWNraW9CYWJlbE9wdGlvbnMsXG5cdFx0XHRcdHRoaXMuY29uZmlnLmpzQmFiZWxQcmVzZXRPcHRpb25zXG5cdFx0XHQpLFxuXHRcdFx0aGFzRmxvdyA/ICdmbG93JyA6IHVuZGVmaW5lZFxuXHRcdCk7XG5cblx0XHRjb25zdCBqc1J1bGVzOiB3ZWJwYWNrLlJ1bGVTZXRSdWxlID0ge1xuXHRcdFx0dGVzdDogL1xcLm0/anN4PyQvLFxuXHRcdFx0dXNlOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2FkZXI6IHJlcXVpcmUucmVzb2x2ZSgnYmFiZWwtbG9hZGVyJyksXG5cdFx0XHRcdFx0b3B0aW9uczogdGhpcy5nZXRGaW5hbEJhYmVsTG9hZGVyT3B0aW9ucyhcblx0XHRcdFx0XHRcdGlzQmFiZWxDb25maWdQcmVzZW50XG5cdFx0XHRcdFx0XHRcdD8ge31cblx0XHRcdFx0XHRcdFx0OiB0aGlzLmdldE92ZXJyaWRlV2VicGFja1J1bGVPcHRpb25zKFxuXHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcmVzZXRzOiBqc1ByZXNldHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGRpc2FibGUgYmFiZWxyYyBhbmQgYmFiZWwuY29uZmlnLmpzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFzIGl0IGNvdWxkIHBvdGVudGlhbGx5IGJyZWFrIHN0dWZmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHJhdGhlciB1c2UgdGhlIGpzQmFiZWxPdmVycmlkZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25maWdGaWxlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmFiZWxyYzogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5jb25maWcuanNCYWJlbE92ZXJyaWRlXG5cdFx0XHRcdFx0XHRcdCAgKVxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdH0sXG5cdFx0XHRdLFxuXHRcdFx0ZXhjbHVkZTogLyhub2RlX21vZHVsZXN8Ym93ZXJfY29tcG9uZW50cykvLFxuXHRcdH07XG5cblx0XHQvLyBjcmVhdGUgdGhlIGJhYmVsIHJ1bGVzIGZvciB0eXBlc2NyaXB0IGNvZGVcblx0XHRjb25zdCB0c1ByZXNldHM6IGJhYmVsUHJlc2V0W10gPSBnZXRCYWJlbFByZXNldHMoXG5cdFx0XHRvdmVycmlkZUJhYmVsUHJlc2V0T3B0aW9ucyhcblx0XHRcdFx0d3BhY2tpb0JhYmVsT3B0aW9ucyxcblx0XHRcdFx0dGhpcy5jb25maWcudHNCYWJlbFByZXNldE9wdGlvbnNcblx0XHRcdCksXG5cdFx0XHQndHlwZXNjcmlwdCdcblx0XHQpO1xuXG5cdFx0Y29uc3QgdHNSdWxlczogd2VicGFjay5SdWxlU2V0UnVsZSA9IHtcblx0XHRcdHRlc3Q6IC9cXC50c3g/JC8sXG5cdFx0XHR1c2U6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvYWRlcjogcmVxdWlyZS5yZXNvbHZlKCdiYWJlbC1sb2FkZXInKSxcblx0XHRcdFx0XHRvcHRpb25zOiB0aGlzLmdldEZpbmFsQmFiZWxMb2FkZXJPcHRpb25zKFxuXHRcdFx0XHRcdFx0aXNCYWJlbENvbmZpZ1ByZXNlbnRcblx0XHRcdFx0XHRcdFx0PyB7fVxuXHRcdFx0XHRcdFx0XHQ6IHRoaXMuZ2V0T3ZlcnJpZGVXZWJwYWNrUnVsZU9wdGlvbnMoXG5cdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByZXNldHM6IHRzUHJlc2V0cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gZGlzYWJsZSBiYWJlbHJjIGFuZCBiYWJlbC5jb25maWcuanNcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYXMgaXQgY291bGQgcG90ZW50aWFsbHkgYnJlYWsgc3R1ZmZcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmF0aGVyIHVzZSB0aGUganNCYWJlbE92ZXJyaWRlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbmZpZ0ZpbGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRiYWJlbHJjOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBwbHVnaW4tcHJvcG9zYWwtY2xhc3MtcHJvcGVydGllc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBiZWNhdXNlIHRha2VuIGNhcmUgb2YgYnkgQHdwYWNraW8vYmFzZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAnQGJhYmVsL3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIG9iamVjdC1yZXN0LXNwcmVhZCBiZWNhdXNlIGl0IGlzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFscmVhZHkgaW4gc3RhZ2UtNCBhbmQgdGFrZW4gY2FyZSBvZiBieSBwcmVzZXQtZW52XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vICdAYmFiZWwvcHJvcG9zYWwtb2JqZWN0LXJlc3Qtc3ByZWFkJyxcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvbmZpZy50c0JhYmVsT3ZlcnJpZGVcblx0XHRcdFx0XHRcdFx0ICApXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0fSxcblx0XHRcdF0sXG5cdFx0XHRleGNsdWRlOiAvKG5vZGVfbW9kdWxlcykvLFxuXHRcdH07XG5cblx0XHQvLyBDb21waWxlIG5vZGVfbW9kdWxlc1xuXHRcdGNvbnN0IG5tSnNSdWxlczogd2VicGFjay5SdWxlU2V0UnVsZSA9IHtcblx0XHRcdHRlc3Q6IC9cXC4oanN8bWpzKSQvLFxuXHRcdFx0Ly8gd2UgZXhjbHVkZSBAYmFiZWwvcnVudGltZSBhbmQgY29yZS1qc1xuXHRcdFx0ZXhjbHVkZTogLyhAYmFiZWwoPzpcXC98XFxcXHsxLDJ9KXJ1bnRpbWUpfChjb3JlLWpzKS8sXG5cdFx0XHRpbmNsdWRlOiAvbm9kZV9tb2R1bGVzLyxcblx0XHRcdHVzZTogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bG9hZGVyOiByZXF1aXJlLnJlc29sdmUoJ2JhYmVsLWxvYWRlcicpLFxuXHRcdFx0XHRcdG9wdGlvbnM6IHRoaXMuZ2V0RmluYWxCYWJlbExvYWRlck9wdGlvbnMoXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIHByZXNldCBmcm9tIG91ciBvd24gcGFja2FnZVxuXHRcdFx0XHRcdFx0XHRwcmVzZXRzOiBnZXRCYWJlbFByZXNldHMoe1xuXHRcdFx0XHRcdFx0XHRcdGhhc1JlYWN0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0XHRcdC8vIElmIGFuIGVycm9yIGhhcHBlbnMgaW4gYSBwYWNrYWdlLCBpdCdzIHBvc3NpYmxlIHRvIGJlXG5cdFx0XHRcdFx0XHRcdC8vIGJlY2F1c2UgaXQgd2FzIGNvbXBpbGVkLiBUaHVzLCB3ZSBkb24ndCB3YW50IHRoZSBicm93c2VyXG5cdFx0XHRcdFx0XHRcdC8vIGRlYnVnZ2VyIHRvIHNob3cgdGhlIG9yaWdpbmFsIGNvZGUuIEluc3RlYWQsIHRoZSBjb2RlXG5cdFx0XHRcdFx0XHRcdC8vIGJlaW5nIGV2YWx1YXRlZCB3b3VsZCBiZSBtdWNoIG1vcmUgaGVscGZ1bC5cblx0XHRcdFx0XHRcdFx0c291cmNlTWFwczogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdC8vIEJhYmVsIGFzc3VtZXMgRVMgTW9kdWxlcywgd2hpY2ggaXNuJ3Qgc2FmZSB1bnRpbCBDb21tb25KU1xuXHRcdFx0XHRcdFx0XHQvLyBkaWVzLiBUaGlzIGNoYW5nZXMgdGhlIGJlaGF2aW9yIHRvIGFzc3VtZSBDb21tb25KUyB1bmxlc3Ncblx0XHRcdFx0XHRcdFx0Ly8gYW4gYGltcG9ydGAgb3IgYGV4cG9ydGAgaXMgcHJlc2VudCBpbiB0aGUgZmlsZS5cblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvNDAzOSNpc3N1ZWNvbW1lbnQtNDE5Mjg0OTQwXG5cdFx0XHRcdFx0XHRcdHNvdXJjZVR5cGU6ICd1bmFtYmlndW91cycsXG5cdFx0XHRcdFx0XHRcdC8vIGRpc2FibGUgYmFiZWxyYyBhbmQgYmFiZWwuY29uZmlnLmpzIGZvciBub2RlX21vZHVsZXNcblx0XHRcdFx0XHRcdFx0Y29uZmlnRmlsZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGJhYmVscmM6IGZhbHNlLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGZhbHNlXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0fSxcblx0XHRcdF0sXG5cdFx0fTtcblxuXHRcdC8vIENyZWF0ZSBzdHlsZSBydWxlc1xuXHRcdGNvbnN0IHN0eWxlUnVsZXM6IHdlYnBhY2suUnVsZVNldFJ1bGVbXSA9IFtcblx0XHRcdHtcblx0XHRcdFx0dGVzdDogL1xcLmNzcyQvLFxuXHRcdFx0XHR1c2U6IFtcblx0XHRcdFx0XHQuLi5nZXRTdHlsZUxvYWRlclVzZXModGhpcy5pc0RldiwgdGhpcy5jb25maWcucHVibGljUGF0aFVybCwgZmFsc2UpLFxuXHRcdFx0XHRdLFxuXHRcdFx0fSxcblx0XHRdO1xuXHRcdC8vIElmIHdlIGhhdmUgc2FzcywgdGhlbiBhZGQgdGhlIHN0dWZmXG5cdFx0aWYgKGhhc1Nhc3MpIHtcblx0XHRcdHN0eWxlUnVsZXMucHVzaCh7XG5cdFx0XHRcdHRlc3Q6IC9cXC5zKGF8YylzcyQvLFxuXHRcdFx0XHR1c2U6IFtcblx0XHRcdFx0XHQuLi5nZXRTdHlsZUxvYWRlclVzZXModGhpcy5pc0RldiwgdGhpcy5jb25maWcucHVibGljUGF0aFVybCwgdHJ1ZSksXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bG9hZGVyOiByZXF1aXJlLnJlc29sdmUoJ3Nhc3MtbG9hZGVyJyksXG5cdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdHNvdXJjZU1hcDogdHJ1ZSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XSxcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBJZiB3ZSBoYXZlIGxlc3MsIHRoZW4gYWRkIHRoZSBzdHVmZlxuXHRcdGlmIChoYXNMZXNzKSB7XG5cdFx0XHRzdHlsZVJ1bGVzLnB1c2goe1xuXHRcdFx0XHR0ZXN0OiAvXFwubGVzcyQvLFxuXHRcdFx0XHR1c2U6IFtcblx0XHRcdFx0XHQuLi5nZXRTdHlsZUxvYWRlclVzZXModGhpcy5pc0RldiwgdGhpcy5jb25maWcucHVibGljUGF0aFVybCwgdHJ1ZSksXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bG9hZGVyOiByZXF1aXJlLnJlc29sdmUoJ2xlc3MtbG9hZGVyJyksXG5cdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdHNvdXJjZU1hcDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0bGVzc09wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRqYXZhc2NyaXB0RW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBmaWxlIHJ1bGVzXG5cdFx0Y29uc3QgeyBmaWxlUnVsZXNOb25TdHlsZSwgZmlsZVJ1bGVzU3R5bGUgfSA9XG5cdFx0XHRnZXRGaWxlTG9hZGVyRm9ySnNBbmRTdHlsZUFzc2V0cyh0aGlzLmFwcERpciwgdGhpcy5pc0Rldik7XG5cblx0XHRjb25zdCBydWxlczogd2VicGFjay5SdWxlU2V0UnVsZVtdID0gW2pzUnVsZXMsIHRzUnVsZXNdO1xuXHRcdGlmICh0aGlzLmlzRGV2ICYmIHRoaXMuY29uZmlnLmNvbXBpbGVOb2RlTW9kdWxlcy5kZXYpIHtcblx0XHRcdHJ1bGVzLnB1c2gobm1Kc1J1bGVzKTtcblx0XHR9IGVsc2UgaWYgKCF0aGlzLmlzRGV2ICYmIHRoaXMuY29uZmlnLmNvbXBpbGVOb2RlTW9kdWxlcy5wcm9kKSB7XG5cdFx0XHRydWxlcy5wdXNoKG5tSnNSdWxlcyk7XG5cdFx0fVxuXHRcdHJ1bGVzLnB1c2goLi4uc3R5bGVSdWxlcywgZmlsZVJ1bGVzTm9uU3R5bGUsIGZpbGVSdWxlc1N0eWxlKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRydWxlcyxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB3ZWJwYWNrIGNvbXBhdGlibGUgcmVzb2x2ZSBwcm9wZXJ0eS5cblx0ICovXG5cdHB1YmxpYyBnZXRSZXNvbHZlKCk6IHdlYnBhY2suUmVzb2x2ZSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dGVuc2lvbnM6IFsnLm1qcycsICcuanMnLCAnLmpzeCcsICcudHMnLCAnLnRzeCddLFxuXHRcdFx0YWxpYXM6IHRoaXMuY29uZmlnLmFsaWFzICE9PSB1bmRlZmluZWQgPyB7IC4uLnRoaXMuY29uZmlnLmFsaWFzIH0gOiB7fSxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBvcHRpbWl6YXRpb24gZm9yIHdlYnBhY2suXG5cdCAqXG5cdCAqIFdlIG9wdGltaXplIGFsbCBjaHVua3MgYmVjYXVzZVxuXHQgKi9cblx0cHVibGljIGdldE9wdGltaXphdGlvbigpOiB3ZWJwYWNrLk9wdGlvbnMuT3B0aW1pemF0aW9uIHwgdW5kZWZpbmVkIHtcblx0XHRjb25zdCB7IG9wdGltaXplU3BsaXRDaHVua3MgfSA9IHRoaXMuY29uZmlnO1xuXHRcdGNvbnN0IG9wdGltaXphdGlvbjogd2VicGFjay5PcHRpb25zLk9wdGltaXphdGlvbiA9IHtcblx0XHRcdC8vIFdlIHNldCBydW50aW1lQ2h1bmsgdG8gYmUgc2luZ2xlXG5cdFx0XHQvLyBiZWNhdXNlIHVzZXIgY2FuIChhbmQgcHJvYmFibHkgc2hvdWxkKVxuXHRcdFx0Ly8gaGF2ZSBtdWx0aXBsZSBlbnRyeS1wb2ludCBvbiB0aGUgc2FtZSBwYWdlXG5cdFx0XHRydW50aW1lQ2h1bms6ICdzaW5nbGUnLFxuXHRcdH07XG5cdFx0aWYgKG9wdGltaXplU3BsaXRDaHVua3MpIHtcblx0XHRcdG9wdGltaXphdGlvbi5zcGxpdENodW5rcyA9IHtcblx0XHRcdFx0Y2h1bmtzOiAnYWxsJyxcblx0XHRcdFx0bWluU2l6ZTogMzAwMDAsXG5cdFx0XHRcdG1pbkNodW5rczogMSxcblx0XHRcdFx0bWF4QXN5bmNSZXF1ZXN0czogNSxcblx0XHRcdFx0bWF4SW5pdGlhbFJlcXVlc3RzOiAzLFxuXHRcdFx0XHRuYW1lOiB0cnVlLFxuXHRcdFx0XHRjYWNoZUdyb3Vwczoge1xuXHRcdFx0XHRcdHZlbmRvcnM6IHtcblx0XHRcdFx0XHRcdHRlc3Q6IC9bXFxcXC9dbm9kZV9tb2R1bGVzW1xcXFwvXS8sXG5cdFx0XHRcdFx0XHRwcmlvcml0eTogLTEwLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdFx0bWluQ2h1bmtzOiAyLFxuXHRcdFx0XHRcdFx0cHJpb3JpdHk6IC0yMCxcblx0XHRcdFx0XHRcdHJldXNlRXhpc3RpbmdDaHVuazogdHJ1ZSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW1pemF0aW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBjb21tb24gY29uZmlndXJhdGlvbiwgZGVwZW5kaW5nIG9uIGp1c3QgZW52aXJvbm1lbnQuXG5cdCAqL1xuXHRwdWJsaWMgZ2V0Q29tbW9uKCk6IENvbW1vbldlYnBhY2tDb25maWcge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjb250ZXh0OiB0aGlzLmN3ZCxcblx0XHRcdGRldnRvb2w6IHRoaXMuaXNEZXYgPyAnY2hlYXAtbW9kdWxlLXNvdXJjZS1tYXAnIDogJ3NvdXJjZS1tYXAnLFxuXHRcdFx0dGFyZ2V0OiAnd2ViJyxcblx0XHRcdHdhdGNoOiB0aGlzLmlzRGV2LFxuXHRcdFx0bW9kZTogdGhpcy5lbnYsXG5cdFx0XHRuYW1lOiB0aGlzLmZpbGUubmFtZSxcblx0XHRcdGV4dGVybmFsczogdGhpcy5jb25maWcuZXh0ZXJuYWxzLFxuXHRcdFx0aW5mcmFzdHJ1Y3R1cmVMb2dnaW5nOiB7XG5cdFx0XHRcdGxldmVsOiAnbm9uZScsXG5cdFx0XHR9LFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGZpbmFsIGJhYmVsIGxvYWRlciBvcHRpb25zLiBUaGlzIGFkZHMgYW55dGhpbmcgbmVjZXNzYXJ5IGZvclxuXHQgKiB3cGFja2lvIGZ1bmN0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIG9wdGlvbnMgRXhpc3RpbmcgYmFiZWwgbG9hZGVyIG9wdGlvbnMuXG5cdCAqL1xuXHRwcml2YXRlIGdldEZpbmFsQmFiZWxMb2FkZXJPcHRpb25zKFxuXHRcdG9wdGlvbnM6IHdlYnBhY2suUnVsZVNldExvYWRlclsnb3B0aW9ucyddLFxuXHRcdGFkZFJlYWN0UmVmcmVzaDogYm9vbGVhbiA9IHRydWVcblx0KTogd2VicGFjay5SdWxlU2V0TG9hZGVyWydvcHRpb25zJ10ge1xuXHRcdGNvbnN0IGZpbmFsT3B0aW9uczogd2VicGFjay5SdWxlU2V0TG9hZGVyWydvcHRpb25zJ10gPVxuXHRcdFx0b3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgPyB7IC4uLm9wdGlvbnMgfSA6IHt9O1xuXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5jb25maWcuaGFzUmVhY3QgJiZcblx0XHRcdCF0aGlzLmNvbmZpZy5kaXNhYmxlUmVhY3RSZWZyZXNoICYmXG5cdFx0XHQhdGhpcy5maWxlLm9wdGltaXplRm9yR3V0ZW5iZXJnICYmXG5cdFx0XHRhZGRSZWFjdFJlZnJlc2ggJiZcblx0XHRcdHRoaXMuaXNEZXZcblx0XHQpIHtcblx0XHRcdGlmICghZmluYWxPcHRpb25zLnBsdWdpbnMpIHtcblx0XHRcdFx0ZmluYWxPcHRpb25zLnBsdWdpbnMgPSBbXTtcblx0XHRcdH1cblx0XHRcdGZpbmFsT3B0aW9ucy5wbHVnaW5zLnB1c2gocmVxdWlyZS5yZXNvbHZlKCdyZWFjdC1yZWZyZXNoL2JhYmVsJykpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGJhYmVsTG9hZGVyQ2FjaGVPcHRpb25zID0ge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGZlYXR1cmUgb2YgYGJhYmVsLWxvYWRlcmAgZm9yIHdlYnBhY2sgKG5vdCBCYWJlbCBpdHNlbGYpLlxuXHRcdFx0Ly8gSXQgZW5hYmxlcyBjYWNoaW5nIHJlc3VsdHMgaW4gLi9ub2RlX21vZHVsZXMvLmNhY2hlL2JhYmVsLWxvYWRlci9cblx0XHRcdC8vIGRpcmVjdG9yeSBmb3IgZmFzdGVyIHJlYnVpbGRzLlxuXHRcdFx0Y2FjaGVEaXJlY3Rvcnk6IHRydWUsXG5cdFx0XHRjYWNoZUNvbXByZXNzaW9uOiAhdGhpcy5pc0Rldixcblx0XHRcdGNvbXBhY3Q6ICF0aGlzLmlzRGV2LFxuXHRcdH07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uZmluYWxPcHRpb25zLFxuXHRcdFx0Li4uYmFiZWxMb2FkZXJDYWNoZU9wdGlvbnMsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgZmluYWwgbG9hZGVyIG9wdGlvbiBiYXNlZCBvbiB1c2VyIGFuZCBzeXN0ZW0uXG5cdCAqXG5cdCAqIEBwYXJhbSBkZWZhdWx0cyBEZWZhdWx0IG9wdGlvbnMgYXMgY2FsY3VsYXRlZCBieSBzeXN0ZW0uXG5cdCAqIEBwYXJhbSBvdmVycmlkZSBVc2VyIGRlZmluZWQgb3B0aW9uLlxuXHQgKi9cblx0cHJpdmF0ZSBnZXRPdmVycmlkZVdlYnBhY2tSdWxlT3B0aW9ucyhcblx0XHRkZWZhdWx0czogd2VicGFjay5SdWxlU2V0TG9hZGVyWydvcHRpb25zJ10sXG5cdFx0b3ZlcnJpZGU6IHdlYnBhY2tMb2FkZXJPcHRpb25zT3ZlcnJpZGVcblx0KTogd2VicGFjay5SdWxlU2V0TG9hZGVyWydvcHRpb25zJ10ge1xuXHRcdC8vIElmIG92ZXJyaWRlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbCwgdGhlbiByZXR1cm4gaXRcblx0XHRpZiAob3ZlcnJpZGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gSWYgaXQgaXMgYSBmdW5jdGlvblxuXHRcdFx0aWYgKHR5cGVvZiBvdmVycmlkZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gb3ZlcnJpZGUoZGVmYXVsdHMgfHwge30pIGFzIHdlYnBhY2suUnVsZVNldExvYWRlclsnb3B0aW9ucyddO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG92ZXJyaWRlO1xuXHRcdH1cblx0XHQvLyBPdGhlcndpc2UganVzdCByZXR1cm4gZGVmYXVsdFxuXHRcdHJldHVybiBkZWZhdWx0cztcblx0fVxuXG5cdHByaXZhdGUgZ2V0RW52VmFyaWFibGVzKCkge1xuXHRcdGNvbnN0IGVudlZhcmlhYmxlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXHRcdGNvbnN0IG1hdGNoID0gJ1dQQUNLSU9fJztcblx0XHRPYmplY3Qua2V5cyhwcm9jZXNzLmVudiA/PyB7fSkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0aWYgKGtleS5zdGFydHNXaXRoKG1hdGNoKSkge1xuXHRcdFx0XHRlbnZWYXJpYWJsZXNbYHByb2Nlc3MuZW52LiR7a2V5LnN1YnN0cmluZyhtYXRjaC5sZW5ndGgpfWBdID1cblx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShwcm9jZXNzLmVudltrZXldKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gZW52VmFyaWFibGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBjYWxjdWxhdGVkIGFwcCBkaXJlY3Rvcnlcblx0ICovXG5cdHB1YmxpYyBnZXRBcHBEaXIoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBEaXI7XG5cdH1cbn1cbiJdfQ==
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CreateWebpackConfig = void 0;

var _webpackMerge = require("webpack-merge");

var _projectConfig = require("./project.config.default");

var _serverConfig = require("./server.config.default");

var _WebpackConfigHelper = require("./WebpackConfigHelper");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Create the final webpack config through this class.
 */
class CreateWebpackConfig {
  /**
   * Create an instance of GetWebpackConfig class.
   *
   * @param projectConfig Project configuration as recovered from user directory.
   * @param serverConfig Server configuration as recovered from user directory.
   * @param isDev Whether this is development mode.
   */
  constructor(projectConfig, serverConfig, cwd, isDev = true) {
    _defineProperty(this, "projectConfig", void 0);

    _defineProperty(this, "serverConfig", void 0);

    _defineProperty(this, "cwd", void 0);

    _defineProperty(this, "isDev", void 0);

    _defineProperty(this, "publicPath", void 0);

    // Create final configuration
    // By doing a shallow override
    this.projectConfig = _objectSpread(_objectSpread({}, _projectConfig.projectConfigDefault), projectConfig);
    this.serverConfig = _objectSpread(_objectSpread({}, _serverConfig.serverConfigDefault), serverConfig);
    this.cwd = cwd;
    this.isDev = isDev; // Also figure out the publicPath beforehand, because we do need it

    const {
      slug,
      outputPath,
      type
    } = this.projectConfig; // The public is generated automatically considering
    // the dev server is installed at root, and wp-content, themes, plugins
    // directories are all default.
    // But one can pass distPublicPath from serverConfig to override it.

    this.publicPath = this.serverConfig.distPublicPath || `/wp-content/${type}s/${slug}/${outputPath}/`;
  }
  /**
   * Get configuration object to feed to webpack.
   *
   * Depending on the project configuration, it could be for single compiler
   * as well as multi compiler.
   *
   * If `projectConfig.files` has length === 1, then it would be a single compiler
   * otherwise, it would be for multi compiler.
   */


  getWebpackConfig() {
    // Now it can be a single compiler, or multicompiler
    // In any case, figure it out, create the compiler options
    // and return the stuff.
    // If the configuration is for multiple compiler mode
    // Then return an array of config.
    if (this.isMultiCompiler()) {
      // Return an array of configuration
      const config = [];
      this.projectConfig.files.forEach(file => {
        config.push(this.getSingleWebpackConfig(file));
      });
      return config;
    } // Otherwise, just return a single compiler mode config


    return this.getSingleWebpackConfig(this.projectConfig.files[0]);
  }
  /**
   * Is the config going to be for multi-compiler?
   */


  isMultiCompiler() {
    return this.projectConfig.files.length > 1;
  }
  /**
   * Get devServer publicPath for all sorts of middlewares.
   */


  getPublicPath() {
    return this.publicPath;
  }
  /**
   * Get Hot Module Reload Path, which we get from WebpackConfigHelper
   * for consistency.
   *
   * This is tweaked so that react fast refresh works.
   */


  getHmrPath() {
    return _WebpackConfigHelper.WebpackConfigHelper.getHmrPath();
  }
  /**
   * Get Url to publicPath.
   */


  getPublicPathUrl() {
    return `${this.getServerUrl()}${this.publicPath}`;
  }
  /**
   * Get server URL where the hot server is live and waiting to become
   * awesome.
   */


  getServerUrl() {
    const {
      host,
      port
    } = this.serverConfig;
    return `//${host || 'localhost'}:${port}`;
  }
  /**
   * Get Webpack Configuration for single compiler mode.
   *
   * @param file Single file object.
   */


  getSingleWebpackConfig(file) {
    var _this$projectConfig$c, _this$projectConfig$c2, _this$projectConfig$c3, _this$projectConfig$c4;

    const {
      type,
      slug,
      hasReact,
      disableReactRefresh,
      hasSass,
      hasLess,
      hasFlow,
      bannerConfig,
      alias,
      optimizeSplitChunks,
      outputPath,
      appName,
      errorOverlay,
      externals,
      jsBabelOverride,
      jsBabelPresetOptions,
      tsBabelOverride,
      tsBabelPresetOptions,
      useReactJsxRuntime,
      disableWordPressExternals
    } = this.projectConfig; // get useBabelConfig from project, but override from file

    let useBabelConfig = this.projectConfig.useBabelConfig;

    if (file.useBabelConfig !== undefined) {
      useBabelConfig = file.useBabelConfig;
    } // figure out compile node modules


    const compileNodeModules = {
      dev: (_this$projectConfig$c = (_this$projectConfig$c2 = this.projectConfig.compileNodeModules) === null || _this$projectConfig$c2 === void 0 ? void 0 : _this$projectConfig$c2.dev) !== null && _this$projectConfig$c !== void 0 ? _this$projectConfig$c : true,
      prod: (_this$projectConfig$c3 = (_this$projectConfig$c4 = this.projectConfig.compileNodeModules) === null || _this$projectConfig$c4 === void 0 ? void 0 : _this$projectConfig$c4.prod) !== null && _this$projectConfig$c3 !== void 0 ? _this$projectConfig$c3 : true
    };
    const {
      host,
      port
    } = this.serverConfig;
    const helper = new _WebpackConfigHelper.WebpackConfigHelper(file, {
      appName,
      type,
      slug,
      host,
      port,
      hasReact,
      disableReactRefresh,
      hasSass,
      hasLess,
      hasFlow,
      bannerConfig,
      alias,
      optimizeSplitChunks,
      outputPath,
      publicPath: this.getPublicPath(),
      publicPathUrl: this.getPublicPathUrl(),
      errorOverlay,
      externals,
      useBabelConfig,
      jsBabelOverride,
      jsBabelPresetOptions,
      tsBabelOverride,
      tsBabelPresetOptions,
      useReactJsxRuntime,
      disableWordPressExternals,
      compileNodeModules
    }, this.cwd, this.isDev); // Now create the config and return it

    let config = _objectSpread({
      name: file.name,
      entry: helper.getEntry(),
      output: helper.getOutput(),
      module: helper.getModule(),
      plugins: helper.getPlugins(),
      resolve: helper.getResolve(),
      optimization: helper.getOptimization()
    }, helper.getCommon()); // Merge options if needed
    // Loose comparison because it could very well be undefined


    if (file.webpackConfig != null) {
      // If it is a function
      if (typeof file.webpackConfig === 'function') {
        config = file.webpackConfig(config, _webpackMerge.merge, helper.getAppDir(), this.isDev);
      } else {
        config = (0, _webpackMerge.merge)(config, file.webpackConfig);
      }
    }

    return config;
  }

}

exports.CreateWebpackConfig = CreateWebpackConfig;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb25maWcvQ3JlYXRlV2VicGFja0NvbmZpZy50cyJdLCJuYW1lcyI6WyJDcmVhdGVXZWJwYWNrQ29uZmlnIiwiY29uc3RydWN0b3IiLCJwcm9qZWN0Q29uZmlnIiwic2VydmVyQ29uZmlnIiwiY3dkIiwiaXNEZXYiLCJwcm9qZWN0Q29uZmlnRGVmYXVsdCIsInNlcnZlckNvbmZpZ0RlZmF1bHQiLCJzbHVnIiwib3V0cHV0UGF0aCIsInR5cGUiLCJwdWJsaWNQYXRoIiwiZGlzdFB1YmxpY1BhdGgiLCJnZXRXZWJwYWNrQ29uZmlnIiwiaXNNdWx0aUNvbXBpbGVyIiwiY29uZmlnIiwiZmlsZXMiLCJmb3JFYWNoIiwiZmlsZSIsInB1c2giLCJnZXRTaW5nbGVXZWJwYWNrQ29uZmlnIiwibGVuZ3RoIiwiZ2V0UHVibGljUGF0aCIsImdldEhtclBhdGgiLCJXZWJwYWNrQ29uZmlnSGVscGVyIiwiZ2V0UHVibGljUGF0aFVybCIsImdldFNlcnZlclVybCIsImhvc3QiLCJwb3J0IiwiaGFzUmVhY3QiLCJkaXNhYmxlUmVhY3RSZWZyZXNoIiwiaGFzU2FzcyIsImhhc0xlc3MiLCJoYXNGbG93IiwiYmFubmVyQ29uZmlnIiwiYWxpYXMiLCJvcHRpbWl6ZVNwbGl0Q2h1bmtzIiwiYXBwTmFtZSIsImVycm9yT3ZlcmxheSIsImV4dGVybmFscyIsImpzQmFiZWxPdmVycmlkZSIsImpzQmFiZWxQcmVzZXRPcHRpb25zIiwidHNCYWJlbE92ZXJyaWRlIiwidHNCYWJlbFByZXNldE9wdGlvbnMiLCJ1c2VSZWFjdEpzeFJ1bnRpbWUiLCJkaXNhYmxlV29yZFByZXNzRXh0ZXJuYWxzIiwidXNlQmFiZWxDb25maWciLCJ1bmRlZmluZWQiLCJjb21waWxlTm9kZU1vZHVsZXMiLCJkZXYiLCJwcm9kIiwiaGVscGVyIiwicHVibGljUGF0aFVybCIsIm5hbWUiLCJlbnRyeSIsImdldEVudHJ5Iiwib3V0cHV0IiwiZ2V0T3V0cHV0IiwibW9kdWxlIiwiZ2V0TW9kdWxlIiwicGx1Z2lucyIsImdldFBsdWdpbnMiLCJyZXNvbHZlIiwiZ2V0UmVzb2x2ZSIsIm9wdGltaXphdGlvbiIsImdldE9wdGltaXphdGlvbiIsImdldENvbW1vbiIsIndlYnBhY2tDb25maWciLCJ3ZWJwYWNrTWVyZ2UiLCJnZXRBcHBEaXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7QUFFQTs7QUFLQTs7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQSxtQkFBTixDQUEwQjtBQVdoQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDQyxFQUFBQSxXQUFXLENBQ1ZDLGFBRFUsRUFFVkMsWUFGVSxFQUdWQyxHQUhVLEVBSVZDLEtBQWMsR0FBRyxJQUpQLEVBS1Q7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFDRDtBQUNBO0FBQ0EsU0FBS0gsYUFBTCxtQ0FDSUksbUNBREosR0FFSUosYUFGSjtBQUlBLFNBQUtDLFlBQUwsbUNBQ0lJLGlDQURKLEdBRUlKLFlBRko7QUFJQSxTQUFLQyxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLQyxLQUFMLEdBQWFBLEtBQWIsQ0FaQyxDQWNEOztBQUNBLFVBQU07QUFBRUcsTUFBQUEsSUFBRjtBQUFRQyxNQUFBQSxVQUFSO0FBQW9CQyxNQUFBQTtBQUFwQixRQUE2QixLQUFLUixhQUF4QyxDQWZDLENBZ0JEO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQUtTLFVBQUwsR0FDQyxLQUFLUixZQUFMLENBQWtCUyxjQUFsQixJQUNDLGVBQWNGLElBQUssS0FBSUYsSUFBSyxJQUFHQyxVQUFXLEdBRjVDO0FBR0E7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNRSSxFQUFBQSxnQkFBZ0IsR0FBb0Q7QUFDMUU7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBLFFBQUksS0FBS0MsZUFBTCxFQUFKLEVBQTRCO0FBQzNCO0FBQ0EsWUFBTUMsTUFBK0IsR0FBRyxFQUF4QztBQUNBLFdBQUtiLGFBQUwsQ0FBbUJjLEtBQW5CLENBQXlCQyxPQUF6QixDQUFrQ0MsSUFBRCxJQUFzQjtBQUN0REgsUUFBQUEsTUFBTSxDQUFDSSxJQUFQLENBQVksS0FBS0Msc0JBQUwsQ0FBNEJGLElBQTVCLENBQVo7QUFDQSxPQUZEO0FBSUEsYUFBT0gsTUFBUDtBQUNBLEtBZnlFLENBaUIxRTs7O0FBQ0EsV0FBTyxLQUFLSyxzQkFBTCxDQUE0QixLQUFLbEIsYUFBTCxDQUFtQmMsS0FBbkIsQ0FBeUIsQ0FBekIsQ0FBNUIsQ0FBUDtBQUNBO0FBRUQ7QUFDRDtBQUNBOzs7QUFDUUYsRUFBQUEsZUFBZSxHQUFZO0FBQ2pDLFdBQU8sS0FBS1osYUFBTCxDQUFtQmMsS0FBbkIsQ0FBeUJLLE1BQXpCLEdBQWtDLENBQXpDO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7OztBQUNRQyxFQUFBQSxhQUFhLEdBQVc7QUFDOUIsV0FBTyxLQUFLWCxVQUFaO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNRWSxFQUFBQSxVQUFVLEdBQVc7QUFDM0IsV0FBT0MseUNBQW9CRCxVQUFwQixFQUFQO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7OztBQUNRRSxFQUFBQSxnQkFBZ0IsR0FBVztBQUNqQyxXQUFRLEdBQUUsS0FBS0MsWUFBTCxFQUFvQixHQUFFLEtBQUtmLFVBQVcsRUFBaEQ7QUFDQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBOzs7QUFDUWUsRUFBQUEsWUFBWSxHQUFXO0FBQzdCLFVBQU07QUFBRUMsTUFBQUEsSUFBRjtBQUFRQyxNQUFBQTtBQUFSLFFBQWlCLEtBQUt6QixZQUE1QjtBQUVBLFdBQVEsS0FBSXdCLElBQUksSUFBSSxXQUFZLElBQUdDLElBQUssRUFBeEM7QUFDQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUNTUixFQUFBQSxzQkFBc0IsQ0FBQ0YsSUFBRCxFQUEwQztBQUFBOztBQUN2RSxVQUFNO0FBQ0xSLE1BQUFBLElBREs7QUFFTEYsTUFBQUEsSUFGSztBQUdMcUIsTUFBQUEsUUFISztBQUlMQyxNQUFBQSxtQkFKSztBQUtMQyxNQUFBQSxPQUxLO0FBTUxDLE1BQUFBLE9BTks7QUFPTEMsTUFBQUEsT0FQSztBQVFMQyxNQUFBQSxZQVJLO0FBU0xDLE1BQUFBLEtBVEs7QUFVTEMsTUFBQUEsbUJBVks7QUFXTDNCLE1BQUFBLFVBWEs7QUFZTDRCLE1BQUFBLE9BWks7QUFhTEMsTUFBQUEsWUFiSztBQWNMQyxNQUFBQSxTQWRLO0FBZUxDLE1BQUFBLGVBZks7QUFnQkxDLE1BQUFBLG9CQWhCSztBQWlCTEMsTUFBQUEsZUFqQks7QUFrQkxDLE1BQUFBLG9CQWxCSztBQW1CTEMsTUFBQUEsa0JBbkJLO0FBb0JMQyxNQUFBQTtBQXBCSyxRQXFCRixLQUFLM0MsYUFyQlQsQ0FEdUUsQ0F1QnZFOztBQUNBLFFBQUk0QyxjQUFjLEdBQUcsS0FBSzVDLGFBQUwsQ0FBbUI0QyxjQUF4Qzs7QUFDQSxRQUFJNUIsSUFBSSxDQUFDNEIsY0FBTCxLQUF3QkMsU0FBNUIsRUFBdUM7QUFDdENELE1BQUFBLGNBQWMsR0FBRzVCLElBQUksQ0FBQzRCLGNBQXRCO0FBQ0EsS0EzQnNFLENBNEJ2RTs7O0FBQ0EsVUFBTUUsa0JBQWtCLEdBQUc7QUFDMUJDLE1BQUFBLEdBQUcscURBQUUsS0FBSy9DLGFBQUwsQ0FBbUI4QyxrQkFBckIsMkRBQUUsdUJBQXVDQyxHQUF6Qyx5RUFBZ0QsSUFEekI7QUFFMUJDLE1BQUFBLElBQUksc0RBQUUsS0FBS2hELGFBQUwsQ0FBbUI4QyxrQkFBckIsMkRBQUUsdUJBQXVDRSxJQUF6QywyRUFBaUQ7QUFGM0IsS0FBM0I7QUFJQSxVQUFNO0FBQUV2QixNQUFBQSxJQUFGO0FBQVFDLE1BQUFBO0FBQVIsUUFBaUIsS0FBS3pCLFlBQTVCO0FBQ0EsVUFBTWdELE1BQTJCLEdBQUcsSUFBSTNCLHdDQUFKLENBQ25DTixJQURtQyxFQUVuQztBQUNDbUIsTUFBQUEsT0FERDtBQUVDM0IsTUFBQUEsSUFGRDtBQUdDRixNQUFBQSxJQUhEO0FBSUNtQixNQUFBQSxJQUpEO0FBS0NDLE1BQUFBLElBTEQ7QUFNQ0MsTUFBQUEsUUFORDtBQU9DQyxNQUFBQSxtQkFQRDtBQVFDQyxNQUFBQSxPQVJEO0FBU0NDLE1BQUFBLE9BVEQ7QUFVQ0MsTUFBQUEsT0FWRDtBQVdDQyxNQUFBQSxZQVhEO0FBWUNDLE1BQUFBLEtBWkQ7QUFhQ0MsTUFBQUEsbUJBYkQ7QUFjQzNCLE1BQUFBLFVBZEQ7QUFlQ0UsTUFBQUEsVUFBVSxFQUFFLEtBQUtXLGFBQUwsRUFmYjtBQWdCQzhCLE1BQUFBLGFBQWEsRUFBRSxLQUFLM0IsZ0JBQUwsRUFoQmhCO0FBaUJDYSxNQUFBQSxZQWpCRDtBQWtCQ0MsTUFBQUEsU0FsQkQ7QUFtQkNPLE1BQUFBLGNBbkJEO0FBb0JDTixNQUFBQSxlQXBCRDtBQXFCQ0MsTUFBQUEsb0JBckJEO0FBc0JDQyxNQUFBQSxlQXRCRDtBQXVCQ0MsTUFBQUEsb0JBdkJEO0FBd0JDQyxNQUFBQSxrQkF4QkQ7QUF5QkNDLE1BQUFBLHlCQXpCRDtBQTBCQ0csTUFBQUE7QUExQkQsS0FGbUMsRUE4Qm5DLEtBQUs1QyxHQTlCOEIsRUErQm5DLEtBQUtDLEtBL0I4QixDQUFwQyxDQWxDdUUsQ0FvRXZFOztBQUNBLFFBQUlVLE1BQTZCO0FBQ2hDc0MsTUFBQUEsSUFBSSxFQUFFbkMsSUFBSSxDQUFDbUMsSUFEcUI7QUFFaENDLE1BQUFBLEtBQUssRUFBRUgsTUFBTSxDQUFDSSxRQUFQLEVBRnlCO0FBR2hDQyxNQUFBQSxNQUFNLEVBQUVMLE1BQU0sQ0FBQ00sU0FBUCxFQUh3QjtBQUloQ0MsTUFBQUEsTUFBTSxFQUFFUCxNQUFNLENBQUNRLFNBQVAsRUFKd0I7QUFLaENDLE1BQUFBLE9BQU8sRUFBRVQsTUFBTSxDQUFDVSxVQUFQLEVBTHVCO0FBTWhDQyxNQUFBQSxPQUFPLEVBQUVYLE1BQU0sQ0FBQ1ksVUFBUCxFQU51QjtBQU9oQ0MsTUFBQUEsWUFBWSxFQUFFYixNQUFNLENBQUNjLGVBQVA7QUFQa0IsT0FRN0JkLE1BQU0sQ0FBQ2UsU0FBUCxFQVI2QixDQUFqQyxDQXJFdUUsQ0FnRnZFO0FBQ0E7OztBQUNBLFFBQUloRCxJQUFJLENBQUNpRCxhQUFMLElBQXNCLElBQTFCLEVBQWdDO0FBQy9CO0FBQ0EsVUFBSSxPQUFPakQsSUFBSSxDQUFDaUQsYUFBWixLQUE4QixVQUFsQyxFQUE4QztBQUM3Q3BELFFBQUFBLE1BQU0sR0FBR0csSUFBSSxDQUFDaUQsYUFBTCxDQUNScEQsTUFEUSxFQUVScUQsbUJBRlEsRUFHUmpCLE1BQU0sQ0FBQ2tCLFNBQVAsRUFIUSxFQUlSLEtBQUtoRSxLQUpHLENBQVQ7QUFNQSxPQVBELE1BT087QUFDTlUsUUFBQUEsTUFBTSxHQUFHLHlCQUFhQSxNQUFiLEVBQXFCRyxJQUFJLENBQUNpRCxhQUExQixDQUFUO0FBQ0E7QUFDRDs7QUFFRCxXQUFPcEQsTUFBUDtBQUNBOztBQTdOK0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgd2VicGFjayBmcm9tICd3ZWJwYWNrJztcbmltcG9ydCB7IG1lcmdlIGFzIHdlYnBhY2tNZXJnZSB9IGZyb20gJ3dlYnBhY2stbWVyZ2UnO1xuXG5pbXBvcnQge1xuXHRGaWxlQ29uZmlnLFxuXHRQcm9qZWN0Q29uZmlnLFxuXHRwcm9qZWN0Q29uZmlnRGVmYXVsdCxcbn0gZnJvbSAnLi9wcm9qZWN0LmNvbmZpZy5kZWZhdWx0JztcbmltcG9ydCB7IFNlcnZlckNvbmZpZywgc2VydmVyQ29uZmlnRGVmYXVsdCB9IGZyb20gJy4vc2VydmVyLmNvbmZpZy5kZWZhdWx0JztcbmltcG9ydCB7IFdlYnBhY2tDb25maWdIZWxwZXIgfSBmcm9tICcuL1dlYnBhY2tDb25maWdIZWxwZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdwYWNrQ29uZmlnIHtcblx0Y29uZmlnOiB3ZWJwYWNrLkNvbmZpZ3VyYXRpb247XG5cdGhtclB1YmxpY1BhdGg6IHN0cmluZztcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGZpbmFsIHdlYnBhY2sgY29uZmlnIHRocm91Z2ggdGhpcyBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENyZWF0ZVdlYnBhY2tDb25maWcge1xuXHRwcml2YXRlIHByb2plY3RDb25maWc6IFByb2plY3RDb25maWc7XG5cblx0cHJpdmF0ZSBzZXJ2ZXJDb25maWc6IFNlcnZlckNvbmZpZztcblxuXHRwcml2YXRlIGN3ZDogc3RyaW5nO1xuXG5cdHByaXZhdGUgaXNEZXY6IGJvb2xlYW47XG5cblx0cHJpdmF0ZSBwdWJsaWNQYXRoOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBHZXRXZWJwYWNrQ29uZmlnIGNsYXNzLlxuXHQgKlxuXHQgKiBAcGFyYW0gcHJvamVjdENvbmZpZyBQcm9qZWN0IGNvbmZpZ3VyYXRpb24gYXMgcmVjb3ZlcmVkIGZyb20gdXNlciBkaXJlY3RvcnkuXG5cdCAqIEBwYXJhbSBzZXJ2ZXJDb25maWcgU2VydmVyIGNvbmZpZ3VyYXRpb24gYXMgcmVjb3ZlcmVkIGZyb20gdXNlciBkaXJlY3RvcnkuXG5cdCAqIEBwYXJhbSBpc0RldiBXaGV0aGVyIHRoaXMgaXMgZGV2ZWxvcG1lbnQgbW9kZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByb2plY3RDb25maWc6IFByb2plY3RDb25maWcsXG5cdFx0c2VydmVyQ29uZmlnOiBTZXJ2ZXJDb25maWcsXG5cdFx0Y3dkOiBzdHJpbmcsXG5cdFx0aXNEZXY6IGJvb2xlYW4gPSB0cnVlXG5cdCkge1xuXHRcdC8vIENyZWF0ZSBmaW5hbCBjb25maWd1cmF0aW9uXG5cdFx0Ly8gQnkgZG9pbmcgYSBzaGFsbG93IG92ZXJyaWRlXG5cdFx0dGhpcy5wcm9qZWN0Q29uZmlnID0ge1xuXHRcdFx0Li4ucHJvamVjdENvbmZpZ0RlZmF1bHQsXG5cdFx0XHQuLi5wcm9qZWN0Q29uZmlnLFxuXHRcdH07XG5cdFx0dGhpcy5zZXJ2ZXJDb25maWcgPSB7XG5cdFx0XHQuLi5zZXJ2ZXJDb25maWdEZWZhdWx0LFxuXHRcdFx0Li4uc2VydmVyQ29uZmlnLFxuXHRcdH07XG5cdFx0dGhpcy5jd2QgPSBjd2Q7XG5cdFx0dGhpcy5pc0RldiA9IGlzRGV2O1xuXG5cdFx0Ly8gQWxzbyBmaWd1cmUgb3V0IHRoZSBwdWJsaWNQYXRoIGJlZm9yZWhhbmQsIGJlY2F1c2Ugd2UgZG8gbmVlZCBpdFxuXHRcdGNvbnN0IHsgc2x1Zywgb3V0cHV0UGF0aCwgdHlwZSB9ID0gdGhpcy5wcm9qZWN0Q29uZmlnO1xuXHRcdC8vIFRoZSBwdWJsaWMgaXMgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgY29uc2lkZXJpbmdcblx0XHQvLyB0aGUgZGV2IHNlcnZlciBpcyBpbnN0YWxsZWQgYXQgcm9vdCwgYW5kIHdwLWNvbnRlbnQsIHRoZW1lcywgcGx1Z2luc1xuXHRcdC8vIGRpcmVjdG9yaWVzIGFyZSBhbGwgZGVmYXVsdC5cblx0XHQvLyBCdXQgb25lIGNhbiBwYXNzIGRpc3RQdWJsaWNQYXRoIGZyb20gc2VydmVyQ29uZmlnIHRvIG92ZXJyaWRlIGl0LlxuXHRcdHRoaXMucHVibGljUGF0aCA9XG5cdFx0XHR0aGlzLnNlcnZlckNvbmZpZy5kaXN0UHVibGljUGF0aCB8fFxuXHRcdFx0YC93cC1jb250ZW50LyR7dHlwZX1zLyR7c2x1Z30vJHtvdXRwdXRQYXRofS9gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBjb25maWd1cmF0aW9uIG9iamVjdCB0byBmZWVkIHRvIHdlYnBhY2suXG5cdCAqXG5cdCAqIERlcGVuZGluZyBvbiB0aGUgcHJvamVjdCBjb25maWd1cmF0aW9uLCBpdCBjb3VsZCBiZSBmb3Igc2luZ2xlIGNvbXBpbGVyXG5cdCAqIGFzIHdlbGwgYXMgbXVsdGkgY29tcGlsZXIuXG5cdCAqXG5cdCAqIElmIGBwcm9qZWN0Q29uZmlnLmZpbGVzYCBoYXMgbGVuZ3RoID09PSAxLCB0aGVuIGl0IHdvdWxkIGJlIGEgc2luZ2xlIGNvbXBpbGVyXG5cdCAqIG90aGVyd2lzZSwgaXQgd291bGQgYmUgZm9yIG11bHRpIGNvbXBpbGVyLlxuXHQgKi9cblx0cHVibGljIGdldFdlYnBhY2tDb25maWcoKTogd2VicGFjay5Db25maWd1cmF0aW9uIHwgd2VicGFjay5Db25maWd1cmF0aW9uW10ge1xuXHRcdC8vIE5vdyBpdCBjYW4gYmUgYSBzaW5nbGUgY29tcGlsZXIsIG9yIG11bHRpY29tcGlsZXJcblx0XHQvLyBJbiBhbnkgY2FzZSwgZmlndXJlIGl0IG91dCwgY3JlYXRlIHRoZSBjb21waWxlciBvcHRpb25zXG5cdFx0Ly8gYW5kIHJldHVybiB0aGUgc3R1ZmYuXG5cblx0XHQvLyBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBmb3IgbXVsdGlwbGUgY29tcGlsZXIgbW9kZVxuXHRcdC8vIFRoZW4gcmV0dXJuIGFuIGFycmF5IG9mIGNvbmZpZy5cblx0XHRpZiAodGhpcy5pc011bHRpQ29tcGlsZXIoKSkge1xuXHRcdFx0Ly8gUmV0dXJuIGFuIGFycmF5IG9mIGNvbmZpZ3VyYXRpb25cblx0XHRcdGNvbnN0IGNvbmZpZzogd2VicGFjay5Db25maWd1cmF0aW9uW10gPSBbXTtcblx0XHRcdHRoaXMucHJvamVjdENvbmZpZy5maWxlcy5mb3JFYWNoKChmaWxlOiBGaWxlQ29uZmlnKSA9PiB7XG5cdFx0XHRcdGNvbmZpZy5wdXNoKHRoaXMuZ2V0U2luZ2xlV2VicGFja0NvbmZpZyhmaWxlKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGNvbmZpZztcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIGEgc2luZ2xlIGNvbXBpbGVyIG1vZGUgY29uZmlnXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2luZ2xlV2VicGFja0NvbmZpZyh0aGlzLnByb2plY3RDb25maWcuZmlsZXNbMF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIElzIHRoZSBjb25maWcgZ29pbmcgdG8gYmUgZm9yIG11bHRpLWNvbXBpbGVyP1xuXHQgKi9cblx0cHVibGljIGlzTXVsdGlDb21waWxlcigpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0Q29uZmlnLmZpbGVzLmxlbmd0aCA+IDE7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGRldlNlcnZlciBwdWJsaWNQYXRoIGZvciBhbGwgc29ydHMgb2YgbWlkZGxld2FyZXMuXG5cdCAqL1xuXHRwdWJsaWMgZ2V0UHVibGljUGF0aCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnB1YmxpY1BhdGg7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IEhvdCBNb2R1bGUgUmVsb2FkIFBhdGgsIHdoaWNoIHdlIGdldCBmcm9tIFdlYnBhY2tDb25maWdIZWxwZXJcblx0ICogZm9yIGNvbnNpc3RlbmN5LlxuXHQgKlxuXHQgKiBUaGlzIGlzIHR3ZWFrZWQgc28gdGhhdCByZWFjdCBmYXN0IHJlZnJlc2ggd29ya3MuXG5cdCAqL1xuXHRwdWJsaWMgZ2V0SG1yUGF0aCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiBXZWJwYWNrQ29uZmlnSGVscGVyLmdldEhtclBhdGgoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgVXJsIHRvIHB1YmxpY1BhdGguXG5cdCAqL1xuXHRwdWJsaWMgZ2V0UHVibGljUGF0aFVybCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiBgJHt0aGlzLmdldFNlcnZlclVybCgpfSR7dGhpcy5wdWJsaWNQYXRofWA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHNlcnZlciBVUkwgd2hlcmUgdGhlIGhvdCBzZXJ2ZXIgaXMgbGl2ZSBhbmQgd2FpdGluZyB0byBiZWNvbWVcblx0ICogYXdlc29tZS5cblx0ICovXG5cdHB1YmxpYyBnZXRTZXJ2ZXJVcmwoKTogc3RyaW5nIHtcblx0XHRjb25zdCB7IGhvc3QsIHBvcnQgfSA9IHRoaXMuc2VydmVyQ29uZmlnO1xuXG5cdFx0cmV0dXJuIGAvLyR7aG9zdCB8fCAnbG9jYWxob3N0J306JHtwb3J0fWA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IFdlYnBhY2sgQ29uZmlndXJhdGlvbiBmb3Igc2luZ2xlIGNvbXBpbGVyIG1vZGUuXG5cdCAqXG5cdCAqIEBwYXJhbSBmaWxlIFNpbmdsZSBmaWxlIG9iamVjdC5cblx0ICovXG5cdHByaXZhdGUgZ2V0U2luZ2xlV2VicGFja0NvbmZpZyhmaWxlOiBGaWxlQ29uZmlnKTogd2VicGFjay5Db25maWd1cmF0aW9uIHtcblx0XHRjb25zdCB7XG5cdFx0XHR0eXBlLFxuXHRcdFx0c2x1Zyxcblx0XHRcdGhhc1JlYWN0LFxuXHRcdFx0ZGlzYWJsZVJlYWN0UmVmcmVzaCxcblx0XHRcdGhhc1Nhc3MsXG5cdFx0XHRoYXNMZXNzLFxuXHRcdFx0aGFzRmxvdyxcblx0XHRcdGJhbm5lckNvbmZpZyxcblx0XHRcdGFsaWFzLFxuXHRcdFx0b3B0aW1pemVTcGxpdENodW5rcyxcblx0XHRcdG91dHB1dFBhdGgsXG5cdFx0XHRhcHBOYW1lLFxuXHRcdFx0ZXJyb3JPdmVybGF5LFxuXHRcdFx0ZXh0ZXJuYWxzLFxuXHRcdFx0anNCYWJlbE92ZXJyaWRlLFxuXHRcdFx0anNCYWJlbFByZXNldE9wdGlvbnMsXG5cdFx0XHR0c0JhYmVsT3ZlcnJpZGUsXG5cdFx0XHR0c0JhYmVsUHJlc2V0T3B0aW9ucyxcblx0XHRcdHVzZVJlYWN0SnN4UnVudGltZSxcblx0XHRcdGRpc2FibGVXb3JkUHJlc3NFeHRlcm5hbHMsXG5cdFx0fSA9IHRoaXMucHJvamVjdENvbmZpZztcblx0XHQvLyBnZXQgdXNlQmFiZWxDb25maWcgZnJvbSBwcm9qZWN0LCBidXQgb3ZlcnJpZGUgZnJvbSBmaWxlXG5cdFx0bGV0IHVzZUJhYmVsQ29uZmlnID0gdGhpcy5wcm9qZWN0Q29uZmlnLnVzZUJhYmVsQ29uZmlnO1xuXHRcdGlmIChmaWxlLnVzZUJhYmVsQ29uZmlnICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHVzZUJhYmVsQ29uZmlnID0gZmlsZS51c2VCYWJlbENvbmZpZztcblx0XHR9XG5cdFx0Ly8gZmlndXJlIG91dCBjb21waWxlIG5vZGUgbW9kdWxlc1xuXHRcdGNvbnN0IGNvbXBpbGVOb2RlTW9kdWxlcyA9IHtcblx0XHRcdGRldjogdGhpcy5wcm9qZWN0Q29uZmlnLmNvbXBpbGVOb2RlTW9kdWxlcz8uZGV2ID8/IHRydWUsXG5cdFx0XHRwcm9kOiB0aGlzLnByb2plY3RDb25maWcuY29tcGlsZU5vZGVNb2R1bGVzPy5wcm9kID8/IHRydWUsXG5cdFx0fTtcblx0XHRjb25zdCB7IGhvc3QsIHBvcnQgfSA9IHRoaXMuc2VydmVyQ29uZmlnO1xuXHRcdGNvbnN0IGhlbHBlcjogV2VicGFja0NvbmZpZ0hlbHBlciA9IG5ldyBXZWJwYWNrQ29uZmlnSGVscGVyKFxuXHRcdFx0ZmlsZSxcblx0XHRcdHtcblx0XHRcdFx0YXBwTmFtZSxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0c2x1Zyxcblx0XHRcdFx0aG9zdCxcblx0XHRcdFx0cG9ydCxcblx0XHRcdFx0aGFzUmVhY3QsXG5cdFx0XHRcdGRpc2FibGVSZWFjdFJlZnJlc2gsXG5cdFx0XHRcdGhhc1Nhc3MsXG5cdFx0XHRcdGhhc0xlc3MsXG5cdFx0XHRcdGhhc0Zsb3csXG5cdFx0XHRcdGJhbm5lckNvbmZpZyxcblx0XHRcdFx0YWxpYXMsXG5cdFx0XHRcdG9wdGltaXplU3BsaXRDaHVua3MsXG5cdFx0XHRcdG91dHB1dFBhdGgsXG5cdFx0XHRcdHB1YmxpY1BhdGg6IHRoaXMuZ2V0UHVibGljUGF0aCgpLFxuXHRcdFx0XHRwdWJsaWNQYXRoVXJsOiB0aGlzLmdldFB1YmxpY1BhdGhVcmwoKSxcblx0XHRcdFx0ZXJyb3JPdmVybGF5LFxuXHRcdFx0XHRleHRlcm5hbHMsXG5cdFx0XHRcdHVzZUJhYmVsQ29uZmlnLFxuXHRcdFx0XHRqc0JhYmVsT3ZlcnJpZGUsXG5cdFx0XHRcdGpzQmFiZWxQcmVzZXRPcHRpb25zLFxuXHRcdFx0XHR0c0JhYmVsT3ZlcnJpZGUsXG5cdFx0XHRcdHRzQmFiZWxQcmVzZXRPcHRpb25zLFxuXHRcdFx0XHR1c2VSZWFjdEpzeFJ1bnRpbWUsXG5cdFx0XHRcdGRpc2FibGVXb3JkUHJlc3NFeHRlcm5hbHMsXG5cdFx0XHRcdGNvbXBpbGVOb2RlTW9kdWxlcyxcblx0XHRcdH0sXG5cdFx0XHR0aGlzLmN3ZCxcblx0XHRcdHRoaXMuaXNEZXZcblx0XHQpO1xuXG5cdFx0Ly8gTm93IGNyZWF0ZSB0aGUgY29uZmlnIGFuZCByZXR1cm4gaXRcblx0XHRsZXQgY29uZmlnOiB3ZWJwYWNrLkNvbmZpZ3VyYXRpb24gPSB7XG5cdFx0XHRuYW1lOiBmaWxlLm5hbWUsXG5cdFx0XHRlbnRyeTogaGVscGVyLmdldEVudHJ5KCksXG5cdFx0XHRvdXRwdXQ6IGhlbHBlci5nZXRPdXRwdXQoKSxcblx0XHRcdG1vZHVsZTogaGVscGVyLmdldE1vZHVsZSgpLFxuXHRcdFx0cGx1Z2luczogaGVscGVyLmdldFBsdWdpbnMoKSxcblx0XHRcdHJlc29sdmU6IGhlbHBlci5nZXRSZXNvbHZlKCksXG5cdFx0XHRvcHRpbWl6YXRpb246IGhlbHBlci5nZXRPcHRpbWl6YXRpb24oKSxcblx0XHRcdC4uLmhlbHBlci5nZXRDb21tb24oKSxcblx0XHR9O1xuXG5cdFx0Ly8gTWVyZ2Ugb3B0aW9ucyBpZiBuZWVkZWRcblx0XHQvLyBMb29zZSBjb21wYXJpc29uIGJlY2F1c2UgaXQgY291bGQgdmVyeSB3ZWxsIGJlIHVuZGVmaW5lZFxuXHRcdGlmIChmaWxlLndlYnBhY2tDb25maWcgIT0gbnVsbCkge1xuXHRcdFx0Ly8gSWYgaXQgaXMgYSBmdW5jdGlvblxuXHRcdFx0aWYgKHR5cGVvZiBmaWxlLndlYnBhY2tDb25maWcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y29uZmlnID0gZmlsZS53ZWJwYWNrQ29uZmlnKFxuXHRcdFx0XHRcdGNvbmZpZyxcblx0XHRcdFx0XHR3ZWJwYWNrTWVyZ2UsXG5cdFx0XHRcdFx0aGVscGVyLmdldEFwcERpcigpLFxuXHRcdFx0XHRcdHRoaXMuaXNEZXZcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbmZpZyA9IHdlYnBhY2tNZXJnZShjb25maWcsIGZpbGUud2VicGFja0NvbmZpZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbmZpZztcblx0fVxufVxuIl19
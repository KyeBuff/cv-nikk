"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Server = void 0;

var _browserSync = _interopRequireDefault(require("browser-sync"));

var _devIp = _interopRequireDefault(require("dev-ip"));

var _open = _interopRequireDefault(require("open"));

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackDevMiddleware = _interopRequireDefault(require("webpack-dev-middleware"));

var _webpackHotMiddleware = _interopRequireDefault(require("webpack-hot-middleware"));

var _logSymbols = _interopRequireDefault(require("log-symbols"));

var _prompts = _interopRequireDefault(require("prompts"));

var _devUtils = require("../dev-utils");

var _CreateWebpackConfig = require("../config/CreateWebpackConfig");

var _ops = require("../dev-utils/ops");

var _WpackioError = require("../errors/WpackioError");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Create a development server with file watching, hot reload and live reload.
 * Everything is done with browserSync and webpack middleware.
 */
class Server {
  static async getEntriesSelection(projectConfig) {
    const questions = [{
      message: 'Select projects to start',
      name: 'entries',
      type: 'multiselect',
      choices: projectConfig.files.map((f, i) => ({
        value: i,
        title: `[${i}] ${f.name || `CONFIG ${i}`}`
      }))
    }];
    const answer = await (0, _prompts.default)(questions);
    return answer.entries.map(i => Number.parseInt(i, 10));
  }
  /**
   * Create an instance.
   *
   * @param projectConfig Project configuration as recovered from user directory.
   * @param serverConfig Server configuration as recovered from user directory.
   */


  constructor(projectConfig, serverConfig, cwd, callbacks, entries) {
    _defineProperty(this, "projectConfig", void 0);

    _defineProperty(this, "serverConfig", void 0);

    _defineProperty(this, "cwd", void 0);

    _defineProperty(this, "isServing", false);

    _defineProperty(this, "bs", void 0);

    _defineProperty(this, "devMiddlewares", void 0);

    _defineProperty(this, "webpackConfig", void 0);

    _defineProperty(this, "isBrowserOpened", false);

    _defineProperty(this, "firstCompileCompleted", false);

    _defineProperty(this, "callbacks", void 0);

    _defineProperty(this, "hasTs", void 0);

    _defineProperty(this, "tsConfigPath", void 0);

    _defineProperty(this, "priorFirstCompileTsMessage", []);

    _defineProperty(this, "addHooks", compiler => {
      // We tap into done and invalid hooks, which are present
      // in both single and multi-compiler instances.
      const {
        done,
        invalid
      } = compiler.hooks; // When compilation is done, call the callback

      done.tap('wpackIoServerDone', stats => {
        // don't do anything if firstCompile hasn't run
        if (this.firstCompileCompleted) {
          const raw = stats.toJson({
            all: false,
            warnings: true,
            errors: true
          });
          const messages = (0, _devUtils.formatWebpackMessages)(raw); // further remove the absolute path

          messages.errors = messages.errors.map(itm => itm.split(this.cwd).join('.'));
          messages.warnings = messages.warnings.map(itm => itm.split(this.cwd).join('.'));

          if (!messages.errors.length && !messages.warnings.length) {
            // Here be pretty stuff.
            this.callbacks.done(stats);
          }

          if (messages.errors.length) {
            this.callbacks.onError(messages);
          } else if (messages.warnings.length) {
            this.callbacks.onWarn(messages);
          }

          this.callbacks.onEmit(stats);

          if (!this.hasTs) {
            this.callbacks.onWatching();
          }
        }
      }); // On compile start

      invalid.tap('wpackIoServerInvalid', () => {
        this.callbacks.invalid();
      }); // some additional work for typescript
      // heavily based on create-react-script
      // Some more hooks on typescript

      if (this.hasTs && this.projectConfig.files.some(f => f.hasTypeScript !== false)) {
        // try to get the fork ts checker webpack plugin
        let ForkTsCheckerWebpackPlugin;

        try {
          // eslint-disable-next-line global-require, import/no-extraneous-dependencies, @typescript-eslint/no-var-requires
          ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');
        } catch (e) {
          throw new _WpackioError.WpackioError('please install fork-ts-checker-webpack-plugin package');
        } // Now here's the tricky thing, it could be either single compiler
        // or multi-compiler


        if ('compilers' in compiler) {
          // It is a multi-compiler instance
          // so tap the hook for every instance
          compiler.compilers.forEach(sCompiler => {
            this.addTsHooks(sCompiler, ForkTsCheckerWebpackPlugin);
          });
        } else {
          // single compiler instance, so just tap one
          this.addTsHooks(compiler, ForkTsCheckerWebpackPlugin);
        }
      }
    });

    _defineProperty(this, "addTsHooks", (compiler, plugin) => {
      const {
        beforeCompile,
        done
      } = compiler.hooks;
      const tsHooks = plugin.getCompilerHooks(compiler);
      let tsMessagesPromise;
      let tsMessagesResolver; // Tap before run begins on watch mode to create a new tsmessage promise

      beforeCompile.tap('wpackIoServerBeforeCompileTs', () => {
        if (!this.firstCompileCompleted) {
          // if this first compilation isn't done yet, and there is a pending
          // resolver, then call it with empty message. For some reason, during
          // initialization, beforeCompile seems to be called multiple times.
          // This is how we cancel the previous resolver and start fresh
          if (tsMessagesResolver) {
            tsMessagesResolver({
              errors: [],
              warnings: [],
              name: compiler.name
            });
          }
        }

        tsMessagesPromise = new Promise(resolve => {
          tsMessagesResolver = msgs => resolve(msgs);
        }); // silently reject the previous promise
        // although it should never happen

        tsMessagesPromise.catch(() => {// do nothing because it might've been cancelled
        });
      });
      tsHooks.issues.tap('afterTypeScriptCheck', issues => {
        const format = message => (0, _devUtils.typescriptFormatter)(message, this.cwd);

        tsMessagesResolver({
          errors: issues.filter(msg => msg.severity === 'error').map(format),
          warnings: issues.filter(msg => msg.severity === 'warning').map(format),
          name: compiler.name
        });
      }); // Once compilation is done, then show the message

      done.tap('wpackIoServerDoneTs', async () => {
        if (this.firstCompileCompleted) {
          const delayedMsg = setTimeout(() => {
            this.callbacks.onTcStart(compiler.name);
          }, 100);

          try {
            const messages = await tsMessagesPromise; // don't display the delayed message of "waiting for type result"

            clearTimeout(delayedMsg); // update the console by passing to the handler

            this.callbacks.onTcEnd(messages);
            this.callbacks.onWatching();
          } catch (e) {// do thing, since it was cancelled
          }
        } else {
          this.priorFirstCompileTsMessage.push(tsMessagesPromise);
        }
      });
    });

    this.projectConfig = _objectSpread({}, projectConfig); // filter project if needed

    if (entries && entries.length) {
      this.projectConfig.files = this.projectConfig.files.filter((f, index) => entries.includes(index));
    }

    this.serverConfig = serverConfig;
    this.cwd = cwd;
    this.callbacks = callbacks; // Override serverConfig host if it is undefined

    if (!this.serverConfig.host) {
      const possibleHost = (0, _devIp.default)();

      if (possibleHost) {
        // eslint-disable-next-line prefer-destructuring
        this.serverConfig.host = possibleHost[0];
      }
    } // Create the webpackConfig


    this.webpackConfig = new _CreateWebpackConfig.CreateWebpackConfig(this.projectConfig, this.serverConfig, this.cwd, true); // Check if project has typescript

    const [hasTs, tsConfigPath] = (0, _ops.hasTypeScript)(this.cwd);
    this.hasTs = hasTs;
    this.tsConfigPath = tsConfigPath;
  }
  /**
   * Serve the webpack/browserSync hybrid server.
   */


  serve() {
    // If server is already running, then throw
    if (this.isServing) {
      throw new Error('Can not serve while the server is already running.');
    } // Create browserSync Instance


    const bs = _browserSync.default.create(); // Init middleware and stuff


    const middlewares = [];
    const devMiddlewares = []; // We can have multi-compiler or single compiler, depending on the config
    // we get. And both of them works for dev and hot middleware.

    let compiler;

    if (this.webpackConfig.isMultiCompiler()) {
      compiler = (0, _webpack.default)(this.webpackConfig.getWebpackConfig());
    } else {
      compiler = (0, _webpack.default)(this.webpackConfig.getWebpackConfig());
    } // Apply only the done hook for the single/multi compiler
    // we pass as webpack.Compiler, because ts don't like it otherwise


    this.addHooks(compiler);
    const devMiddleware = (0, _webpackDevMiddleware.default)(compiler, {
      stats: false,
      publicPath: this.webpackConfig.getPublicPath()
    });
    const hotMiddleware = (0, _webpackHotMiddleware.default)(compiler, {
      // Now because we are already using publicPath(dynamicPublicPath = true) in client
      // we have to assume that it is prefixed. That's why we prefix it in the server too.
      // Because it could be multi-compiler, I guess it will just work fine since we are
      // passing in the `name` too, as documented.
      path: `${this.webpackConfig.getHmrPath()}`,
      // We don't want any noise
      log: false
    }); // Push them

    middlewares.push(devMiddleware);
    devMiddlewares.push(devMiddleware);
    middlewares.push(hotMiddleware); // Init browsersync
    // BS options

    let bsOptions = {
      logLevel: 'silent',
      port: this.serverConfig.port,
      ui: this.serverConfig.ui,
      proxy: {
        target: this.serverConfig.proxy
      },
      // Middleware for webpack hot reload
      middleware: middlewares,
      host: this.serverConfig.host,
      open: false,
      // We don't want to open right away
      notify: this.serverConfig.notify,
      ghostMode: this.serverConfig.ghostMode === undefined ? {
        clicks: true,
        forms: true,
        scroll: true
      } : this.serverConfig.ghostMode,
      snippetOptions: {
        whitelist: [// Add WP REST API
        '/wp-json/**', // Add AJAX calls
        '/wp-admin/admin-ajax.php']
      }
    };

    if (this.serverConfig.bsOverride) {
      bsOptions = _objectSpread(_objectSpread({}, bsOptions), this.serverConfig.bsOverride);
    } // Open browser on first build


    devMiddleware.waitUntilValid(stats => {
      if (!this.firstCompileCompleted) {
        this.firstCompileCompleted = true;
        this.callbacks.firstCompile(stats); // Some stuff for async ts checking

        if (this.priorFirstCompileTsMessage.length) {
          const delayedMsg = setTimeout(() => {
            this.callbacks.onTcStart();
          }, 100);
          Promise.all(this.priorFirstCompileTsMessage).then(msgs => {
            clearTimeout(delayedMsg);
            msgs.forEach(msg => {
              this.callbacks.onTcEnd(msg);
              this.callbacks.onWatching();
            });
          }).catch(e => {
            console.log(e);
            console.log('first compile ts message failed'); // do nothing because it might be that it has been cancelled.
          });
        } else {
          this.callbacks.onWatching();
        }
      }

      this.openBrowser();
    });
    bs.init(bsOptions); // Watch for user defined files, when it changes, reload
    // When that change, reload

    if (this.projectConfig.watch) {
      bs.watch(this.projectConfig.watch).on('change', file => {
        this.callbacks.onBsChange(file);
        bs.reload();
      });
    } // We don't need to watch for manifest, because if user is changing
    // Config, then she does need to restart. It won't be picked up
    // automatically by node.
    // Mark server is running


    this.isServing = true; // Store the instances

    this.bs = bs;
    this.devMiddlewares = devMiddlewares;
  }
  /**
   * Get URL to network IP where the server is alive.
   */


  getServerUrl() {
    const protocol = this.serverConfig.proxy.startsWith('https') ? 'https' : 'http';
    return `${protocol}:${this.webpackConfig.getServerUrl()}`;
  }
  /**
   * Get URL to browserSync UI.
   */


  getBsUiUrl() {
    const {
      host,
      ui
    } = this.serverConfig;

    if (!ui) {
      return false;
    }

    return `http://${host || 'localhost'}:${ui.port || '8080'}`;
  }
  /**
   * Open browser if not already opened and config says so.
   */


  async openBrowser() {
    const serverUrl = this.getServerUrl();

    if (!this.isBrowserOpened && this.serverConfig.open) {
      this.callbacks.onInfo(`trying to open URL`, _logSymbols.default.info);

      try {
        await (0, _open.default)(serverUrl, {});
        this.callbacks.onInfo(`opened browser with URL ${serverUrl}`, _logSymbols.default.success);
      } catch (e) {
        // do nothing
        this.callbacks.onInfo(`could not open browser`, _logSymbols.default.error);
      }

      this.isBrowserOpened = true;
    }
  }
  /**
   * Add hooks to compiler instances.
   */


  /**
   * Stop the server and clean up all processes.
   */
  stop() {
    // throw if server is not running
    if (!this.isServing) {
      throw new Error('Can not stop if the server is not running already. Call server.serve() first.');
    } // First stop browserSync


    if (this.bs) {
      this.bs.exit();
    } // Now stop all webpack compiler


    if (this.devMiddlewares) {
      this.devMiddlewares.forEach(devMiddleware => {
        devMiddleware.close();
      });
    } // All good

  }
  /**
   * Recompile everything through webpack.
   */


  refresh() {
    // throw if server is not running
    if (!this.isServing) {
      throw new Error('Can not refresh if the server is not running already. Call server.serve() first.');
    } // Refresh all devMiddlewares


    if (this.devMiddlewares) {
      this.devMiddlewares.forEach(devMiddleware => {
        devMiddleware.invalidate();
      });
    } // We probably? don't need anything with browserSync?

  }

}

exports.Server = Server;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JpcHRzL1NlcnZlci50cyJdLCJuYW1lcyI6WyJTZXJ2ZXIiLCJnZXRFbnRyaWVzU2VsZWN0aW9uIiwicHJvamVjdENvbmZpZyIsInF1ZXN0aW9ucyIsIm1lc3NhZ2UiLCJuYW1lIiwidHlwZSIsImNob2ljZXMiLCJmaWxlcyIsIm1hcCIsImYiLCJpIiwidmFsdWUiLCJ0aXRsZSIsImFuc3dlciIsImVudHJpZXMiLCJOdW1iZXIiLCJwYXJzZUludCIsImNvbnN0cnVjdG9yIiwic2VydmVyQ29uZmlnIiwiY3dkIiwiY2FsbGJhY2tzIiwiY29tcGlsZXIiLCJkb25lIiwiaW52YWxpZCIsImhvb2tzIiwidGFwIiwic3RhdHMiLCJmaXJzdENvbXBpbGVDb21wbGV0ZWQiLCJyYXciLCJ0b0pzb24iLCJhbGwiLCJ3YXJuaW5ncyIsImVycm9ycyIsIm1lc3NhZ2VzIiwiaXRtIiwic3BsaXQiLCJqb2luIiwibGVuZ3RoIiwib25FcnJvciIsIm9uV2FybiIsIm9uRW1pdCIsImhhc1RzIiwib25XYXRjaGluZyIsInNvbWUiLCJoYXNUeXBlU2NyaXB0IiwiRm9ya1RzQ2hlY2tlcldlYnBhY2tQbHVnaW4iLCJyZXF1aXJlIiwiZSIsIldwYWNraW9FcnJvciIsImNvbXBpbGVycyIsImZvckVhY2giLCJzQ29tcGlsZXIiLCJhZGRUc0hvb2tzIiwicGx1Z2luIiwiYmVmb3JlQ29tcGlsZSIsInRzSG9va3MiLCJnZXRDb21waWxlckhvb2tzIiwidHNNZXNzYWdlc1Byb21pc2UiLCJ0c01lc3NhZ2VzUmVzb2x2ZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1zZ3MiLCJjYXRjaCIsImlzc3VlcyIsImZvcm1hdCIsImZpbHRlciIsIm1zZyIsInNldmVyaXR5IiwiZGVsYXllZE1zZyIsInNldFRpbWVvdXQiLCJvblRjU3RhcnQiLCJjbGVhclRpbWVvdXQiLCJvblRjRW5kIiwicHJpb3JGaXJzdENvbXBpbGVUc01lc3NhZ2UiLCJwdXNoIiwiaW5kZXgiLCJpbmNsdWRlcyIsImhvc3QiLCJwb3NzaWJsZUhvc3QiLCJ3ZWJwYWNrQ29uZmlnIiwiQ3JlYXRlV2VicGFja0NvbmZpZyIsInRzQ29uZmlnUGF0aCIsInNlcnZlIiwiaXNTZXJ2aW5nIiwiRXJyb3IiLCJicyIsImJyb3dzZXJTeW5jIiwiY3JlYXRlIiwibWlkZGxld2FyZXMiLCJkZXZNaWRkbGV3YXJlcyIsImlzTXVsdGlDb21waWxlciIsImdldFdlYnBhY2tDb25maWciLCJhZGRIb29rcyIsImRldk1pZGRsZXdhcmUiLCJwdWJsaWNQYXRoIiwiZ2V0UHVibGljUGF0aCIsImhvdE1pZGRsZXdhcmUiLCJwYXRoIiwiZ2V0SG1yUGF0aCIsImxvZyIsImJzT3B0aW9ucyIsImxvZ0xldmVsIiwicG9ydCIsInVpIiwicHJveHkiLCJ0YXJnZXQiLCJtaWRkbGV3YXJlIiwib3BlbiIsIm5vdGlmeSIsImdob3N0TW9kZSIsInVuZGVmaW5lZCIsImNsaWNrcyIsImZvcm1zIiwic2Nyb2xsIiwic25pcHBldE9wdGlvbnMiLCJ3aGl0ZWxpc3QiLCJic092ZXJyaWRlIiwid2FpdFVudGlsVmFsaWQiLCJmaXJzdENvbXBpbGUiLCJ0aGVuIiwiY29uc29sZSIsIm9wZW5Ccm93c2VyIiwiaW5pdCIsIndhdGNoIiwib24iLCJmaWxlIiwib25Cc0NoYW5nZSIsInJlbG9hZCIsImdldFNlcnZlclVybCIsInByb3RvY29sIiwic3RhcnRzV2l0aCIsImdldEJzVWlVcmwiLCJzZXJ2ZXJVcmwiLCJpc0Jyb3dzZXJPcGVuZWQiLCJvbkluZm8iLCJsb2dTeW1ib2xzIiwiaW5mbyIsInN1Y2Nlc3MiLCJlcnJvciIsInN0b3AiLCJleGl0IiwiY2xvc2UiLCJyZWZyZXNoIiwiaW52YWxpZGF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUtBOztBQUdBOztBQUNBOzs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUEsTUFBTixD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QUFDQTs7QUFDRCxXQUFLTCxlQUFMLEdBQXVCLElBQXZCO0FBQ0E7QUFDRDtBQUVEO0FBQ0Q7QUFDQTs7O0FBbUpDO0FBQ0Q7QUFDQTtBQUNRTSxFQUFBQSxJQUFJLEdBQVM7QUFDbkI7QUFDQSxRQUFJLENBQUMsS0FBS3hELFNBQVYsRUFBcUI7QUFDcEIsWUFBTSxJQUFJQyxLQUFKLENBQ0wsK0VBREssQ0FBTjtBQUdBLEtBTmtCLENBT25COzs7QUFDQSxRQUFJLEtBQUtDLEVBQVQsRUFBYTtBQUNaLFdBQUtBLEVBQUwsQ0FBUXVELElBQVI7QUFDQSxLQVZrQixDQVduQjs7O0FBQ0EsUUFBSSxLQUFLbkQsY0FBVCxFQUF5QjtBQUN4QixXQUFLQSxjQUFMLENBQW9CdkMsT0FBcEIsQ0FBNEIyQyxhQUFhLElBQUk7QUFDNUNBLFFBQUFBLGFBQWEsQ0FBQ2dELEtBQWQ7QUFDQSxPQUZEO0FBR0EsS0FoQmtCLENBaUJuQjs7QUFDQTtBQUVEO0FBQ0Q7QUFDQTs7O0FBQ1FDLEVBQUFBLE9BQU8sR0FBUztBQUN0QjtBQUNBLFFBQUksQ0FBQyxLQUFLM0QsU0FBVixFQUFxQjtBQUNwQixZQUFNLElBQUlDLEtBQUosQ0FDTCxrRkFESyxDQUFOO0FBR0EsS0FOcUIsQ0FPdEI7OztBQUNBLFFBQUksS0FBS0ssY0FBVCxFQUF5QjtBQUN4QixXQUFLQSxjQUFMLENBQW9CdkMsT0FBcEIsQ0FBNEIyQyxhQUFhLElBQUk7QUFDNUNBLFFBQUFBLGFBQWEsQ0FBQ2tELFVBQWQ7QUFDQSxPQUZEO0FBR0EsS0FacUIsQ0FhdEI7O0FBQ0E7O0FBcGRrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMgKi9cbmltcG9ydCBicm93c2VyU3luYyBmcm9tICdicm93c2VyLXN5bmMnO1xuaW1wb3J0IGRldklwIGZyb20gJ2Rldi1pcCc7XG5pbXBvcnQgb3BlbiBmcm9tICdvcGVuJztcbmltcG9ydCB3ZWJwYWNrIGZyb20gJ3dlYnBhY2snO1xuaW1wb3J0IHdlYnBhY2tEZXZNaWRkbGV3YXJlIGZyb20gJ3dlYnBhY2stZGV2LW1pZGRsZXdhcmUnO1xuaW1wb3J0IHdlYnBhY2tIb3RNaWRkbGV3YXJlIGZyb20gJ3dlYnBhY2staG90LW1pZGRsZXdhcmUnO1xuaW1wb3J0IGxvZ1N5bWJvbHMgZnJvbSAnbG9nLXN5bWJvbHMnO1xuaW1wb3J0IHByb21wdHMgZnJvbSAncHJvbXB0cyc7XG5cbmltcG9ydCB7XG5cdHR5cGVzY3JpcHRGb3JtYXR0ZXIsXG5cdGlzc3VlVHlwZSxcblx0Zm9ybWF0V2VicGFja01lc3NhZ2VzLFxufSBmcm9tICcuLi9kZXYtdXRpbHMnO1xuaW1wb3J0IHsgQ3JlYXRlV2VicGFja0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9DcmVhdGVXZWJwYWNrQ29uZmlnJztcbmltcG9ydCB7IFByb2plY3RDb25maWcgfSBmcm9tICcuLi9jb25maWcvcHJvamVjdC5jb25maWcuZGVmYXVsdCc7XG5pbXBvcnQgeyBTZXJ2ZXJDb25maWcgfSBmcm9tICcuLi9jb25maWcvc2VydmVyLmNvbmZpZy5kZWZhdWx0JztcbmltcG9ydCB7IGhhc1R5cGVTY3JpcHQgfSBmcm9tICcuLi9kZXYtdXRpbHMvb3BzJztcbmltcG9ydCB7IFdwYWNraW9FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9XcGFja2lvRXJyb3InO1xuXG5pbnRlcmZhY2UgRm9ybWF0dGVkTWVzc2FnZSB7XG5cdGVycm9yczogc3RyaW5nW107XG5cdHdhcm5pbmdzOiBzdHJpbmdbXTtcblx0bmFtZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENhbGxiYWNrcyB7XG5cdGludmFsaWQoKTogdm9pZDtcblx0ZG9uZShzdGF0czogd2VicGFjay5TdGF0cyk6IHZvaWQ7XG5cdGZpcnN0Q29tcGlsZShzdGF0czogd2VicGFjay5TdGF0cyB8IHVuZGVmaW5lZCk6IHZvaWQ7XG5cdG9uRXJyb3IoZXJyOiBGb3JtYXR0ZWRNZXNzYWdlKTogdm9pZDtcblx0b25XYXJuKHdhcm46IEZvcm1hdHRlZE1lc3NhZ2UpOiB2b2lkO1xuXHRvbkJzQ2hhbmdlKGZpbGU6IHN0cmluZyk6IHZvaWQ7XG5cdG9uRW1pdChzdGF0czogd2VicGFjay5TdGF0cyk6IHZvaWQ7XG5cdG9uVGNTdGFydChuYW1lPzogc3RyaW5nKTogdm9pZDtcblx0b25UY0VuZChlcnI6IEZvcm1hdHRlZE1lc3NhZ2UpOiB2b2lkO1xuXHRvbldhdGNoaW5nKCk6IHZvaWQ7XG5cdG9uSW5mbyhtc2c6IHN0cmluZywgc3ltYm9sOiBzdHJpbmcpOiB2b2lkO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRldmVsb3BtZW50IHNlcnZlciB3aXRoIGZpbGUgd2F0Y2hpbmcsIGhvdCByZWxvYWQgYW5kIGxpdmUgcmVsb2FkLlxuICogRXZlcnl0aGluZyBpcyBkb25lIHdpdGggYnJvd3NlclN5bmMgYW5kIHdlYnBhY2sgbWlkZGxld2FyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlcnZlciB7XG5cdHByaXZhdGUgcHJvamVjdENvbmZpZzogUHJvamVjdENvbmZpZztcblxuXHRwcml2YXRlIHNlcnZlckNvbmZpZzogU2VydmVyQ29uZmlnO1xuXG5cdHByaXZhdGUgY3dkOiBzdHJpbmc7XG5cblx0cHJpdmF0ZSBpc1NlcnZpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHRwcml2YXRlIGJzPzogYnJvd3NlclN5bmMuQnJvd3NlclN5bmNJbnN0YW5jZTtcblxuXHRwcml2YXRlIGRldk1pZGRsZXdhcmVzPzogd2VicGFja0Rldk1pZGRsZXdhcmUuV2VicGFja0Rldk1pZGRsZXdhcmVbXTtcblxuXHRwcml2YXRlIHdlYnBhY2tDb25maWc6IENyZWF0ZVdlYnBhY2tDb25maWc7XG5cblx0cHJpdmF0ZSBpc0Jyb3dzZXJPcGVuZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHRwcml2YXRlIGZpcnN0Q29tcGlsZUNvbXBsZXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdHByaXZhdGUgY2FsbGJhY2tzOiBDYWxsYmFja3M7XG5cblx0cHJpdmF0ZSBoYXNUczogYm9vbGVhbjtcblxuXHRwcml2YXRlIHRzQ29uZmlnUGF0aDogc3RyaW5nO1xuXG5cdHByaXZhdGUgcHJpb3JGaXJzdENvbXBpbGVUc01lc3NhZ2U6IFByb21pc2U8Rm9ybWF0dGVkTWVzc2FnZT5bXSA9IFtdO1xuXG5cdHN0YXRpYyBhc3luYyBnZXRFbnRyaWVzU2VsZWN0aW9uKFxuXHRcdHByb2plY3RDb25maWc6IFByb2plY3RDb25maWdcblx0KTogUHJvbWlzZTxudW1iZXJbXT4ge1xuXHRcdHR5cGUgcHJvbXB0QW5zd2VyS2V5cyA9ICdlbnRyaWVzJztcblx0XHRjb25zdCBxdWVzdGlvbnM6IHByb21wdHMuUHJvbXB0T2JqZWN0PHByb21wdEFuc3dlcktleXM+W10gPSBbXG5cdFx0XHR7XG5cdFx0XHRcdG1lc3NhZ2U6ICdTZWxlY3QgcHJvamVjdHMgdG8gc3RhcnQnLFxuXHRcdFx0XHRuYW1lOiAnZW50cmllcycsXG5cdFx0XHRcdHR5cGU6ICdtdWx0aXNlbGVjdCcsXG5cdFx0XHRcdGNob2ljZXM6IHByb2plY3RDb25maWcuZmlsZXMubWFwKChmLCBpKSA9PiAoe1xuXHRcdFx0XHRcdHZhbHVlOiBpLFxuXHRcdFx0XHRcdHRpdGxlOiBgWyR7aX1dICR7Zi5uYW1lIHx8IGBDT05GSUcgJHtpfWB9YCxcblx0XHRcdFx0fSkpLFxuXHRcdFx0fSxcblx0XHRdO1xuXG5cdFx0Y29uc3QgYW5zd2VyID0gYXdhaXQgcHJvbXB0cyhxdWVzdGlvbnMpO1xuXHRcdHJldHVybiBhbnN3ZXIuZW50cmllcy5tYXAoKGk6IHN0cmluZykgPT4gTnVtYmVyLnBhcnNlSW50KGksIDEwKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGFuIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gcHJvamVjdENvbmZpZyBQcm9qZWN0IGNvbmZpZ3VyYXRpb24gYXMgcmVjb3ZlcmVkIGZyb20gdXNlciBkaXJlY3RvcnkuXG5cdCAqIEBwYXJhbSBzZXJ2ZXJDb25maWcgU2VydmVyIGNvbmZpZ3VyYXRpb24gYXMgcmVjb3ZlcmVkIGZyb20gdXNlciBkaXJlY3RvcnkuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcm9qZWN0Q29uZmlnOiBQcm9qZWN0Q29uZmlnLFxuXHRcdHNlcnZlckNvbmZpZzogU2VydmVyQ29uZmlnLFxuXHRcdGN3ZDogc3RyaW5nLFxuXHRcdGNhbGxiYWNrczogQ2FsbGJhY2tzLFxuXHRcdGVudHJpZXM/OiBudW1iZXJbXVxuXHQpIHtcblx0XHR0aGlzLnByb2plY3RDb25maWcgPSB7IC4uLnByb2plY3RDb25maWcgfTtcblx0XHQvLyBmaWx0ZXIgcHJvamVjdCBpZiBuZWVkZWRcblx0XHRpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5wcm9qZWN0Q29uZmlnLmZpbGVzID0gdGhpcy5wcm9qZWN0Q29uZmlnLmZpbGVzLmZpbHRlcigoZiwgaW5kZXgpID0+XG5cdFx0XHRcdGVudHJpZXMuaW5jbHVkZXMoaW5kZXgpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHR0aGlzLnNlcnZlckNvbmZpZyA9IHNlcnZlckNvbmZpZztcblx0XHR0aGlzLmN3ZCA9IGN3ZDtcblx0XHR0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcblx0XHQvLyBPdmVycmlkZSBzZXJ2ZXJDb25maWcgaG9zdCBpZiBpdCBpcyB1bmRlZmluZWRcblx0XHRpZiAoIXRoaXMuc2VydmVyQ29uZmlnLmhvc3QpIHtcblx0XHRcdGNvbnN0IHBvc3NpYmxlSG9zdCA9IGRldklwKCk7XG5cdFx0XHRpZiAocG9zc2libGVIb3N0KSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXHRcdFx0XHR0aGlzLnNlcnZlckNvbmZpZy5ob3N0ID0gcG9zc2libGVIb3N0WzBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBDcmVhdGUgdGhlIHdlYnBhY2tDb25maWdcblx0XHR0aGlzLndlYnBhY2tDb25maWcgPSBuZXcgQ3JlYXRlV2VicGFja0NvbmZpZyhcblx0XHRcdHRoaXMucHJvamVjdENvbmZpZyxcblx0XHRcdHRoaXMuc2VydmVyQ29uZmlnLFxuXHRcdFx0dGhpcy5jd2QsXG5cdFx0XHR0cnVlXG5cdFx0KTtcblx0XHQvLyBDaGVjayBpZiBwcm9qZWN0IGhhcyB0eXBlc2NyaXB0XG5cdFx0Y29uc3QgW2hhc1RzLCB0c0NvbmZpZ1BhdGhdID0gaGFzVHlwZVNjcmlwdCh0aGlzLmN3ZCk7XG5cdFx0dGhpcy5oYXNUcyA9IGhhc1RzO1xuXHRcdHRoaXMudHNDb25maWdQYXRoID0gdHNDb25maWdQYXRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlcnZlIHRoZSB3ZWJwYWNrL2Jyb3dzZXJTeW5jIGh5YnJpZCBzZXJ2ZXIuXG5cdCAqL1xuXHRwdWJsaWMgc2VydmUoKTogdm9pZCB7XG5cdFx0Ly8gSWYgc2VydmVyIGlzIGFscmVhZHkgcnVubmluZywgdGhlbiB0aHJvd1xuXHRcdGlmICh0aGlzLmlzU2VydmluZykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHNlcnZlIHdoaWxlIHRoZSBzZXJ2ZXIgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuXHRcdH1cblx0XHQvLyBDcmVhdGUgYnJvd3NlclN5bmMgSW5zdGFuY2Vcblx0XHRjb25zdCBicyA9IGJyb3dzZXJTeW5jLmNyZWF0ZSgpO1xuXG5cdFx0Ly8gSW5pdCBtaWRkbGV3YXJlIGFuZCBzdHVmZlxuXHRcdGNvbnN0IG1pZGRsZXdhcmVzOiBicm93c2VyU3luYy5NaWRkbGV3YXJlSGFuZGxlcltdID0gW107XG5cdFx0Y29uc3QgZGV2TWlkZGxld2FyZXM6IHdlYnBhY2tEZXZNaWRkbGV3YXJlLldlYnBhY2tEZXZNaWRkbGV3YXJlW10gPSBbXTtcblxuXHRcdC8vIFdlIGNhbiBoYXZlIG11bHRpLWNvbXBpbGVyIG9yIHNpbmdsZSBjb21waWxlciwgZGVwZW5kaW5nIG9uIHRoZSBjb25maWdcblx0XHQvLyB3ZSBnZXQuIEFuZCBib3RoIG9mIHRoZW0gd29ya3MgZm9yIGRldiBhbmQgaG90IG1pZGRsZXdhcmUuXG5cdFx0bGV0IGNvbXBpbGVyOiB3ZWJwYWNrLkNvbXBpbGVyIHwgd2VicGFjay5NdWx0aUNvbXBpbGVyO1xuXHRcdGlmICh0aGlzLndlYnBhY2tDb25maWcuaXNNdWx0aUNvbXBpbGVyKCkpIHtcblx0XHRcdGNvbXBpbGVyID0gd2VicGFjayhcblx0XHRcdFx0dGhpcy53ZWJwYWNrQ29uZmlnLmdldFdlYnBhY2tDb25maWcoKSBhcyB3ZWJwYWNrLkNvbmZpZ3VyYXRpb25bXVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29tcGlsZXIgPSB3ZWJwYWNrKFxuXHRcdFx0XHR0aGlzLndlYnBhY2tDb25maWcuZ2V0V2VicGFja0NvbmZpZygpIGFzIHdlYnBhY2suQ29uZmlndXJhdGlvblxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBvbmx5IHRoZSBkb25lIGhvb2sgZm9yIHRoZSBzaW5nbGUvbXVsdGkgY29tcGlsZXJcblx0XHQvLyB3ZSBwYXNzIGFzIHdlYnBhY2suQ29tcGlsZXIsIGJlY2F1c2UgdHMgZG9uJ3QgbGlrZSBpdCBvdGhlcndpc2Vcblx0XHR0aGlzLmFkZEhvb2tzKGNvbXBpbGVyIGFzIHdlYnBhY2suQ29tcGlsZXIpO1xuXG5cdFx0Y29uc3QgZGV2TWlkZGxld2FyZSA9IHdlYnBhY2tEZXZNaWRkbGV3YXJlKFxuXHRcdFx0Y29tcGlsZXIgYXMgYW55LFxuXHRcdFx0e1xuXHRcdFx0XHRzdGF0czogZmFsc2UsXG5cdFx0XHRcdHB1YmxpY1BhdGg6IHRoaXMud2VicGFja0NvbmZpZy5nZXRQdWJsaWNQYXRoKCksXG5cdFx0XHR9IGFzIHdlYnBhY2tEZXZNaWRkbGV3YXJlLk9wdGlvbnNcblx0XHQpO1xuXG5cdFx0Y29uc3QgaG90TWlkZGxld2FyZSA9IHdlYnBhY2tIb3RNaWRkbGV3YXJlKGNvbXBpbGVyLCB7XG5cdFx0XHQvLyBOb3cgYmVjYXVzZSB3ZSBhcmUgYWxyZWFkeSB1c2luZyBwdWJsaWNQYXRoKGR5bmFtaWNQdWJsaWNQYXRoID0gdHJ1ZSkgaW4gY2xpZW50XG5cdFx0XHQvLyB3ZSBoYXZlIHRvIGFzc3VtZSB0aGF0IGl0IGlzIHByZWZpeGVkLiBUaGF0J3Mgd2h5IHdlIHByZWZpeCBpdCBpbiB0aGUgc2VydmVyIHRvby5cblx0XHRcdC8vIEJlY2F1c2UgaXQgY291bGQgYmUgbXVsdGktY29tcGlsZXIsIEkgZ3Vlc3MgaXQgd2lsbCBqdXN0IHdvcmsgZmluZSBzaW5jZSB3ZSBhcmVcblx0XHRcdC8vIHBhc3NpbmcgaW4gdGhlIGBuYW1lYCB0b28sIGFzIGRvY3VtZW50ZWQuXG5cdFx0XHRwYXRoOiBgJHt0aGlzLndlYnBhY2tDb25maWcuZ2V0SG1yUGF0aCgpfWAsXG5cdFx0XHQvLyBXZSBkb24ndCB3YW50IGFueSBub2lzZVxuXHRcdFx0bG9nOiBmYWxzZSxcblx0XHR9KTtcblx0XHQvLyBQdXNoIHRoZW1cblx0XHRtaWRkbGV3YXJlcy5wdXNoKGRldk1pZGRsZXdhcmUpO1xuXHRcdGRldk1pZGRsZXdhcmVzLnB1c2goZGV2TWlkZGxld2FyZSk7XG5cdFx0bWlkZGxld2FyZXMucHVzaChob3RNaWRkbGV3YXJlKTtcblxuXHRcdC8vIEluaXQgYnJvd3NlcnN5bmNcblx0XHQvLyBCUyBvcHRpb25zXG5cdFx0bGV0IGJzT3B0aW9uczogYnJvd3NlclN5bmMuT3B0aW9ucyA9IHtcblx0XHRcdGxvZ0xldmVsOiAnc2lsZW50Jyxcblx0XHRcdHBvcnQ6IHRoaXMuc2VydmVyQ29uZmlnLnBvcnQsXG5cdFx0XHR1aTogdGhpcy5zZXJ2ZXJDb25maWcudWksXG5cdFx0XHRwcm94eToge1xuXHRcdFx0XHR0YXJnZXQ6IHRoaXMuc2VydmVyQ29uZmlnLnByb3h5LFxuXHRcdFx0fSxcblx0XHRcdC8vIE1pZGRsZXdhcmUgZm9yIHdlYnBhY2sgaG90IHJlbG9hZFxuXHRcdFx0bWlkZGxld2FyZTogbWlkZGxld2FyZXMsXG5cdFx0XHRob3N0OiB0aGlzLnNlcnZlckNvbmZpZy5ob3N0LFxuXHRcdFx0b3BlbjogZmFsc2UsIC8vIFdlIGRvbid0IHdhbnQgdG8gb3BlbiByaWdodCBhd2F5XG5cdFx0XHRub3RpZnk6IHRoaXMuc2VydmVyQ29uZmlnLm5vdGlmeSxcblx0XHRcdGdob3N0TW9kZTpcblx0XHRcdFx0dGhpcy5zZXJ2ZXJDb25maWcuZ2hvc3RNb2RlID09PSB1bmRlZmluZWRcblx0XHRcdFx0XHQ/IHtcblx0XHRcdFx0XHRcdFx0Y2xpY2tzOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRmb3JtczogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0c2Nyb2xsOiB0cnVlLFxuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdDogdGhpcy5zZXJ2ZXJDb25maWcuZ2hvc3RNb2RlLFxuXHRcdFx0c25pcHBldE9wdGlvbnM6IHtcblx0XHRcdFx0d2hpdGVsaXN0OiBbXG5cdFx0XHRcdFx0Ly8gQWRkIFdQIFJFU1QgQVBJXG5cdFx0XHRcdFx0Jy93cC1qc29uLyoqJyxcblx0XHRcdFx0XHQvLyBBZGQgQUpBWCBjYWxsc1xuXHRcdFx0XHRcdCcvd3AtYWRtaW4vYWRtaW4tYWpheC5waHAnLFxuXHRcdFx0XHRdLFxuXHRcdFx0fSxcblx0XHR9O1xuXHRcdGlmICh0aGlzLnNlcnZlckNvbmZpZy5ic092ZXJyaWRlKSB7XG5cdFx0XHRic09wdGlvbnMgPSB7XG5cdFx0XHRcdC4uLmJzT3B0aW9ucyxcblx0XHRcdFx0Li4udGhpcy5zZXJ2ZXJDb25maWcuYnNPdmVycmlkZSxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gT3BlbiBicm93c2VyIG9uIGZpcnN0IGJ1aWxkXG5cdFx0ZGV2TWlkZGxld2FyZS53YWl0VW50aWxWYWxpZChzdGF0cyA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuZmlyc3RDb21waWxlQ29tcGxldGVkKSB7XG5cdFx0XHRcdHRoaXMuZmlyc3RDb21waWxlQ29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5jYWxsYmFja3MuZmlyc3RDb21waWxlKHN0YXRzIGFzIGFueSk7XG5cdFx0XHRcdC8vIFNvbWUgc3R1ZmYgZm9yIGFzeW5jIHRzIGNoZWNraW5nXG5cdFx0XHRcdGlmICh0aGlzLnByaW9yRmlyc3RDb21waWxlVHNNZXNzYWdlLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNvbnN0IGRlbGF5ZWRNc2cgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuY2FsbGJhY2tzLm9uVGNTdGFydCgpO1xuXHRcdFx0XHRcdH0sIDEwMCk7XG5cdFx0XHRcdFx0UHJvbWlzZS5hbGwodGhpcy5wcmlvckZpcnN0Q29tcGlsZVRzTWVzc2FnZSlcblx0XHRcdFx0XHRcdC50aGVuKG1zZ3MgPT4ge1xuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoZGVsYXllZE1zZyk7XG5cdFx0XHRcdFx0XHRcdG1zZ3MuZm9yRWFjaChtc2cgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY2FsbGJhY2tzLm9uVGNFbmQobXNnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNhbGxiYWNrcy5vbldhdGNoaW5nKCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5jYXRjaChlID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coZSk7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdmaXJzdCBjb21waWxlIHRzIG1lc3NhZ2UgZmFpbGVkJyk7XG5cdFx0XHRcdFx0XHRcdC8vIGRvIG5vdGhpbmcgYmVjYXVzZSBpdCBtaWdodCBiZSB0aGF0IGl0IGhhcyBiZWVuIGNhbmNlbGxlZC5cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2tzLm9uV2F0Y2hpbmcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5vcGVuQnJvd3NlcigpO1xuXHRcdH0pO1xuXG5cdFx0YnMuaW5pdChic09wdGlvbnMpO1xuXHRcdC8vIFdhdGNoIGZvciB1c2VyIGRlZmluZWQgZmlsZXMsIHdoZW4gaXQgY2hhbmdlcywgcmVsb2FkXG5cdFx0Ly8gV2hlbiB0aGF0IGNoYW5nZSwgcmVsb2FkXG5cdFx0aWYgKHRoaXMucHJvamVjdENvbmZpZy53YXRjaCkge1xuXHRcdFx0YnMud2F0Y2godGhpcy5wcm9qZWN0Q29uZmlnLndhdGNoIGFzIHN0cmluZykub24oXG5cdFx0XHRcdCdjaGFuZ2UnLFxuXHRcdFx0XHQoZmlsZTogc3RyaW5nKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFja3Mub25Cc0NoYW5nZShmaWxlKTtcblx0XHRcdFx0XHRicy5yZWxvYWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0byB3YXRjaCBmb3IgbWFuaWZlc3QsIGJlY2F1c2UgaWYgdXNlciBpcyBjaGFuZ2luZ1xuXHRcdC8vIENvbmZpZywgdGhlbiBzaGUgZG9lcyBuZWVkIHRvIHJlc3RhcnQuIEl0IHdvbid0IGJlIHBpY2tlZCB1cFxuXHRcdC8vIGF1dG9tYXRpY2FsbHkgYnkgbm9kZS5cblxuXHRcdC8vIE1hcmsgc2VydmVyIGlzIHJ1bm5pbmdcblx0XHR0aGlzLmlzU2VydmluZyA9IHRydWU7XG5cblx0XHQvLyBTdG9yZSB0aGUgaW5zdGFuY2VzXG5cdFx0dGhpcy5icyA9IGJzO1xuXHRcdHRoaXMuZGV2TWlkZGxld2FyZXMgPSBkZXZNaWRkbGV3YXJlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgVVJMIHRvIG5ldHdvcmsgSVAgd2hlcmUgdGhlIHNlcnZlciBpcyBhbGl2ZS5cblx0ICovXG5cdHB1YmxpYyBnZXRTZXJ2ZXJVcmwoKTogc3RyaW5nIHtcblx0XHRjb25zdCBwcm90b2NvbCA9IHRoaXMuc2VydmVyQ29uZmlnLnByb3h5LnN0YXJ0c1dpdGgoJ2h0dHBzJylcblx0XHRcdD8gJ2h0dHBzJ1xuXHRcdFx0OiAnaHR0cCc7XG5cdFx0cmV0dXJuIGAke3Byb3RvY29sfToke3RoaXMud2VicGFja0NvbmZpZy5nZXRTZXJ2ZXJVcmwoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBVUkwgdG8gYnJvd3NlclN5bmMgVUkuXG5cdCAqL1xuXHRwdWJsaWMgZ2V0QnNVaVVybCgpOiBzdHJpbmcgfCBib29sZWFuIHtcblx0XHRjb25zdCB7IGhvc3QsIHVpIH0gPSB0aGlzLnNlcnZlckNvbmZpZztcblx0XHRpZiAoIXVpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBgaHR0cDovLyR7aG9zdCB8fCAnbG9jYWxob3N0J306JHt1aS5wb3J0IHx8ICc4MDgwJ31gO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW4gYnJvd3NlciBpZiBub3QgYWxyZWFkeSBvcGVuZWQgYW5kIGNvbmZpZyBzYXlzIHNvLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIG9wZW5Ccm93c2VyKCkge1xuXHRcdGNvbnN0IHNlcnZlclVybCA9IHRoaXMuZ2V0U2VydmVyVXJsKCk7XG5cdFx0aWYgKCF0aGlzLmlzQnJvd3Nlck9wZW5lZCAmJiB0aGlzLnNlcnZlckNvbmZpZy5vcGVuKSB7XG5cdFx0XHR0aGlzLmNhbGxiYWNrcy5vbkluZm8oYHRyeWluZyB0byBvcGVuIFVSTGAsIGxvZ1N5bWJvbHMuaW5mbyk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhd2FpdCBvcGVuKHNlcnZlclVybCwge30pO1xuXHRcdFx0XHR0aGlzLmNhbGxiYWNrcy5vbkluZm8oXG5cdFx0XHRcdFx0YG9wZW5lZCBicm93c2VyIHdpdGggVVJMICR7c2VydmVyVXJsfWAsXG5cdFx0XHRcdFx0bG9nU3ltYm9scy5zdWNjZXNzXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0dGhpcy5jYWxsYmFja3Mub25JbmZvKGBjb3VsZCBub3Qgb3BlbiBicm93c2VyYCwgbG9nU3ltYm9scy5lcnJvcik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmlzQnJvd3Nlck9wZW5lZCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBob29rcyB0byBjb21waWxlciBpbnN0YW5jZXMuXG5cdCAqL1xuXHRwdWJsaWMgYWRkSG9va3MgPSAoY29tcGlsZXI6IHdlYnBhY2suQ29tcGlsZXIpOiB2b2lkID0+IHtcblx0XHQvLyBXZSB0YXAgaW50byBkb25lIGFuZCBpbnZhbGlkIGhvb2tzLCB3aGljaCBhcmUgcHJlc2VudFxuXHRcdC8vIGluIGJvdGggc2luZ2xlIGFuZCBtdWx0aS1jb21waWxlciBpbnN0YW5jZXMuXG5cdFx0Y29uc3QgeyBkb25lLCBpbnZhbGlkIH0gPSBjb21waWxlci5ob29rcztcblxuXHRcdC8vIFdoZW4gY29tcGlsYXRpb24gaXMgZG9uZSwgY2FsbCB0aGUgY2FsbGJhY2tcblx0XHRkb25lLnRhcCgnd3BhY2tJb1NlcnZlckRvbmUnLCBzdGF0cyA9PiB7XG5cdFx0XHQvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBmaXJzdENvbXBpbGUgaGFzbid0IHJ1blxuXHRcdFx0aWYgKHRoaXMuZmlyc3RDb21waWxlQ29tcGxldGVkKSB7XG5cdFx0XHRcdGNvbnN0IHJhdyA9IHN0YXRzLnRvSnNvbih7XG5cdFx0XHRcdFx0YWxsOiBmYWxzZSxcblx0XHRcdFx0XHR3YXJuaW5nczogdHJ1ZSxcblx0XHRcdFx0XHRlcnJvcnM6IHRydWUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjb25zdCBtZXNzYWdlcyA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyhyYXcpO1xuXHRcdFx0XHQvLyBmdXJ0aGVyIHJlbW92ZSB0aGUgYWJzb2x1dGUgcGF0aFxuXHRcdFx0XHRtZXNzYWdlcy5lcnJvcnMgPSBtZXNzYWdlcy5lcnJvcnMubWFwKChpdG06IHN0cmluZykgPT5cblx0XHRcdFx0XHRpdG0uc3BsaXQodGhpcy5jd2QpLmpvaW4oJy4nKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRtZXNzYWdlcy53YXJuaW5ncyA9IG1lc3NhZ2VzLndhcm5pbmdzLm1hcCgoaXRtOiBzdHJpbmcpID0+XG5cdFx0XHRcdFx0aXRtLnNwbGl0KHRoaXMuY3dkKS5qb2luKCcuJylcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKCFtZXNzYWdlcy5lcnJvcnMubGVuZ3RoICYmICFtZXNzYWdlcy53YXJuaW5ncy5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBIZXJlIGJlIHByZXR0eSBzdHVmZi5cblx0XHRcdFx0XHR0aGlzLmNhbGxiYWNrcy5kb25lKHN0YXRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWVzc2FnZXMuZXJyb3JzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IobWVzc2FnZXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1lc3NhZ2VzLndhcm5pbmdzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2tzLm9uV2FybihtZXNzYWdlcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNhbGxiYWNrcy5vbkVtaXQoc3RhdHMpO1xuXG5cdFx0XHRcdGlmICghdGhpcy5oYXNUcykge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2tzLm9uV2F0Y2hpbmcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gT24gY29tcGlsZSBzdGFydFxuXHRcdGludmFsaWQudGFwKCd3cGFja0lvU2VydmVySW52YWxpZCcsICgpID0+IHtcblx0XHRcdHRoaXMuY2FsbGJhY2tzLmludmFsaWQoKTtcblx0XHR9KTtcblxuXHRcdC8vIHNvbWUgYWRkaXRpb25hbCB3b3JrIGZvciB0eXBlc2NyaXB0XG5cdFx0Ly8gaGVhdmlseSBiYXNlZCBvbiBjcmVhdGUtcmVhY3Qtc2NyaXB0XG5cblx0XHQvLyBTb21lIG1vcmUgaG9va3Mgb24gdHlwZXNjcmlwdFxuXHRcdGlmIChcblx0XHRcdHRoaXMuaGFzVHMgJiZcblx0XHRcdHRoaXMucHJvamVjdENvbmZpZy5maWxlcy5zb21lKGYgPT4gZi5oYXNUeXBlU2NyaXB0ICE9PSBmYWxzZSlcblx0XHQpIHtcblx0XHRcdC8vIHRyeSB0byBnZXQgdGhlIGZvcmsgdHMgY2hlY2tlciB3ZWJwYWNrIHBsdWdpblxuXHRcdFx0bGV0IEZvcmtUc0NoZWNrZXJXZWJwYWNrUGx1Z2luOiBhbnk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuXHRcdFx0XHRGb3JrVHNDaGVja2VyV2VicGFja1BsdWdpbiA9IHJlcXVpcmUoJ2ZvcmstdHMtY2hlY2tlci13ZWJwYWNrLXBsdWdpbicpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgV3BhY2tpb0Vycm9yKFxuXHRcdFx0XHRcdCdwbGVhc2UgaW5zdGFsbCBmb3JrLXRzLWNoZWNrZXItd2VicGFjay1wbHVnaW4gcGFja2FnZSdcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm93IGhlcmUncyB0aGUgdHJpY2t5IHRoaW5nLCBpdCBjb3VsZCBiZSBlaXRoZXIgc2luZ2xlIGNvbXBpbGVyXG5cdFx0XHQvLyBvciBtdWx0aS1jb21waWxlclxuXHRcdFx0aWYgKCdjb21waWxlcnMnIGluIGNvbXBpbGVyKSB7XG5cdFx0XHRcdC8vIEl0IGlzIGEgbXVsdGktY29tcGlsZXIgaW5zdGFuY2Vcblx0XHRcdFx0Ly8gc28gdGFwIHRoZSBob29rIGZvciBldmVyeSBpbnN0YW5jZVxuXHRcdFx0XHQoKGNvbXBpbGVyIGFzIGFueSkuY29tcGlsZXJzIGFzIHdlYnBhY2suQ29tcGlsZXJbXSkuZm9yRWFjaChcblx0XHRcdFx0XHRzQ29tcGlsZXIgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5hZGRUc0hvb2tzKHNDb21waWxlciwgRm9ya1RzQ2hlY2tlcldlYnBhY2tQbHVnaW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNpbmdsZSBjb21waWxlciBpbnN0YW5jZSwgc28ganVzdCB0YXAgb25lXG5cdFx0XHRcdHRoaXMuYWRkVHNIb29rcyhjb21waWxlciwgRm9ya1RzQ2hlY2tlcldlYnBhY2tQbHVnaW4pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRwcml2YXRlIGFkZFRzSG9va3MgPSAoY29tcGlsZXI6IHdlYnBhY2suQ29tcGlsZXIsIHBsdWdpbjogYW55KTogdm9pZCA9PiB7XG5cdFx0Y29uc3QgeyBiZWZvcmVDb21waWxlLCBkb25lIH0gPSBjb21waWxlci5ob29rcztcblx0XHRjb25zdCB0c0hvb2tzID0gcGx1Z2luLmdldENvbXBpbGVySG9va3MoY29tcGlsZXIpO1xuXG5cdFx0bGV0IHRzTWVzc2FnZXNQcm9taXNlOiBQcm9taXNlPEZvcm1hdHRlZE1lc3NhZ2U+O1xuXHRcdGxldCB0c01lc3NhZ2VzUmVzb2x2ZXI6IChtc2dzOiBGb3JtYXR0ZWRNZXNzYWdlKSA9PiB2b2lkO1xuXG5cdFx0Ly8gVGFwIGJlZm9yZSBydW4gYmVnaW5zIG9uIHdhdGNoIG1vZGUgdG8gY3JlYXRlIGEgbmV3IHRzbWVzc2FnZSBwcm9taXNlXG5cdFx0YmVmb3JlQ29tcGlsZS50YXAoJ3dwYWNrSW9TZXJ2ZXJCZWZvcmVDb21waWxlVHMnLCAoKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuZmlyc3RDb21waWxlQ29tcGxldGVkKSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgZmlyc3QgY29tcGlsYXRpb24gaXNuJ3QgZG9uZSB5ZXQsIGFuZCB0aGVyZSBpcyBhIHBlbmRpbmdcblx0XHRcdFx0Ly8gcmVzb2x2ZXIsIHRoZW4gY2FsbCBpdCB3aXRoIGVtcHR5IG1lc3NhZ2UuIEZvciBzb21lIHJlYXNvbiwgZHVyaW5nXG5cdFx0XHRcdC8vIGluaXRpYWxpemF0aW9uLCBiZWZvcmVDb21waWxlIHNlZW1zIHRvIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cblx0XHRcdFx0Ly8gVGhpcyBpcyBob3cgd2UgY2FuY2VsIHRoZSBwcmV2aW91cyByZXNvbHZlciBhbmQgc3RhcnQgZnJlc2hcblx0XHRcdFx0aWYgKHRzTWVzc2FnZXNSZXNvbHZlcikge1xuXHRcdFx0XHRcdHRzTWVzc2FnZXNSZXNvbHZlcih7XG5cdFx0XHRcdFx0XHRlcnJvcnM6IFtdLFxuXHRcdFx0XHRcdFx0d2FybmluZ3M6IFtdLFxuXHRcdFx0XHRcdFx0bmFtZTogY29tcGlsZXIubmFtZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dHNNZXNzYWdlc1Byb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRcdFx0dHNNZXNzYWdlc1Jlc29sdmVyID0gbXNncyA9PiByZXNvbHZlKG1zZ3MpO1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBzaWxlbnRseSByZWplY3QgdGhlIHByZXZpb3VzIHByb21pc2Vcblx0XHRcdC8vIGFsdGhvdWdoIGl0IHNob3VsZCBuZXZlciBoYXBwZW5cblx0XHRcdHRzTWVzc2FnZXNQcm9taXNlLmNhdGNoKCgpID0+IHtcblx0XHRcdFx0Ly8gZG8gbm90aGluZyBiZWNhdXNlIGl0IG1pZ2h0J3ZlIGJlZW4gY2FuY2VsbGVkXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRzSG9va3MuaXNzdWVzLnRhcCgnYWZ0ZXJUeXBlU2NyaXB0Q2hlY2snLCAoaXNzdWVzOiBpc3N1ZVR5cGVbXSkgPT4ge1xuXHRcdFx0Y29uc3QgZm9ybWF0ID0gKG1lc3NhZ2U6IGFueSkgPT4gdHlwZXNjcmlwdEZvcm1hdHRlcihtZXNzYWdlLCB0aGlzLmN3ZCk7XG5cblx0XHRcdHRzTWVzc2FnZXNSZXNvbHZlcih7XG5cdFx0XHRcdGVycm9yczogaXNzdWVzLmZpbHRlcihtc2cgPT4gbXNnLnNldmVyaXR5ID09PSAnZXJyb3InKS5tYXAoZm9ybWF0KSxcblx0XHRcdFx0d2FybmluZ3M6IGlzc3Vlcy5maWx0ZXIobXNnID0+IG1zZy5zZXZlcml0eSA9PT0gJ3dhcm5pbmcnKS5tYXAoZm9ybWF0KSxcblx0XHRcdFx0bmFtZTogY29tcGlsZXIubmFtZSxcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gT25jZSBjb21waWxhdGlvbiBpcyBkb25lLCB0aGVuIHNob3cgdGhlIG1lc3NhZ2Vcblx0XHRkb25lLnRhcCgnd3BhY2tJb1NlcnZlckRvbmVUcycsIGFzeW5jICgpID0+IHtcblx0XHRcdGlmICh0aGlzLmZpcnN0Q29tcGlsZUNvbXBsZXRlZCkge1xuXHRcdFx0XHRjb25zdCBkZWxheWVkTXNnID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFja3Mub25UY1N0YXJ0KGNvbXBpbGVyLm5hbWUpO1xuXHRcdFx0XHR9LCAxMDApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgdHNNZXNzYWdlc1Byb21pc2U7XG5cblx0XHRcdFx0XHQvLyBkb24ndCBkaXNwbGF5IHRoZSBkZWxheWVkIG1lc3NhZ2Ugb2YgXCJ3YWl0aW5nIGZvciB0eXBlIHJlc3VsdFwiXG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KGRlbGF5ZWRNc2cpO1xuXHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgY29uc29sZSBieSBwYXNzaW5nIHRvIHRoZSBoYW5kbGVyXG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFja3Mub25UY0VuZChtZXNzYWdlcyk7XG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFja3Mub25XYXRjaGluZygpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly8gZG8gdGhpbmcsIHNpbmNlIGl0IHdhcyBjYW5jZWxsZWRcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wcmlvckZpcnN0Q29tcGlsZVRzTWVzc2FnZS5wdXNoKHRzTWVzc2FnZXNQcm9taXNlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCB0aGUgc2VydmVyIGFuZCBjbGVhbiB1cCBhbGwgcHJvY2Vzc2VzLlxuXHQgKi9cblx0cHVibGljIHN0b3AoKTogdm9pZCB7XG5cdFx0Ly8gdGhyb3cgaWYgc2VydmVyIGlzIG5vdCBydW5uaW5nXG5cdFx0aWYgKCF0aGlzLmlzU2VydmluZykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnQ2FuIG5vdCBzdG9wIGlmIHRoZSBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcgYWxyZWFkeS4gQ2FsbCBzZXJ2ZXIuc2VydmUoKSBmaXJzdC4nXG5cdFx0XHQpO1xuXHRcdH1cblx0XHQvLyBGaXJzdCBzdG9wIGJyb3dzZXJTeW5jXG5cdFx0aWYgKHRoaXMuYnMpIHtcblx0XHRcdHRoaXMuYnMuZXhpdCgpO1xuXHRcdH1cblx0XHQvLyBOb3cgc3RvcCBhbGwgd2VicGFjayBjb21waWxlclxuXHRcdGlmICh0aGlzLmRldk1pZGRsZXdhcmVzKSB7XG5cdFx0XHR0aGlzLmRldk1pZGRsZXdhcmVzLmZvckVhY2goZGV2TWlkZGxld2FyZSA9PiB7XG5cdFx0XHRcdGRldk1pZGRsZXdhcmUuY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBBbGwgZ29vZFxuXHR9XG5cblx0LyoqXG5cdCAqIFJlY29tcGlsZSBldmVyeXRoaW5nIHRocm91Z2ggd2VicGFjay5cblx0ICovXG5cdHB1YmxpYyByZWZyZXNoKCk6IHZvaWQge1xuXHRcdC8vIHRocm93IGlmIHNlcnZlciBpcyBub3QgcnVubmluZ1xuXHRcdGlmICghdGhpcy5pc1NlcnZpbmcpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J0NhbiBub3QgcmVmcmVzaCBpZiB0aGUgc2VydmVyIGlzIG5vdCBydW5uaW5nIGFscmVhZHkuIENhbGwgc2VydmVyLnNlcnZlKCkgZmlyc3QuJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0Ly8gUmVmcmVzaCBhbGwgZGV2TWlkZGxld2FyZXNcblx0XHRpZiAodGhpcy5kZXZNaWRkbGV3YXJlcykge1xuXHRcdFx0dGhpcy5kZXZNaWRkbGV3YXJlcy5mb3JFYWNoKGRldk1pZGRsZXdhcmUgPT4ge1xuXHRcdFx0XHRkZXZNaWRkbGV3YXJlLmludmFsaWRhdGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBXZSBwcm9iYWJseT8gZG9uJ3QgbmVlZCBhbnl0aGluZyB3aXRoIGJyb3dzZXJTeW5jP1xuXHR9XG59XG4iXX0=
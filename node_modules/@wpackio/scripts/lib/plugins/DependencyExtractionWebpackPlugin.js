"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependencyExtractionWebpackPlugin = void 0;

var _webpack = _interopRequireDefault(require("webpack"));

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _ops = require("../dev-utils/ops");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class DependencyExtractionWebpackPlugin {
  constructor(options = {
    gutenbergOptimized: false,
    appDir: ''
  }) {
    _defineProperty(this, "externalizedDeps", void 0);

    _defineProperty(this, "externalsPlugin", void 0);

    _defineProperty(this, "compiler", null);

    _defineProperty(this, "assetDependenciesData", void 0);

    _defineProperty(this, "options", void 0);

    this.options = _objectSpread({}, options);
    /*
     * Track requests that are externalized.
     *
     * Because we don't have a closed set of dependencies, we need to track what has
     * been externalized so we can recognize them in a later phase when the dependency
     * lists are generated.
     */

    this.externalizedDeps = new Set(); // Offload externalization work to the ExternalsPlugin.

    this.externalsPlugin = new _webpack.default.ExternalsPlugin('window', this.externalizeWpDeps.bind(this));
    this.assetDependenciesData = [];
  }

  externalizeWpDeps(_context, request, callback) {
    let externalRequest = (0, _ops.wpackioRequestsToExternals)(request);

    if (this.options.gutenbergOptimized) {
      externalRequest = (0, _ops.defaultRequestToExternal)(request);
    }

    if (externalRequest) {
      this.externalizedDeps.add(request);
      return callback(null, externalRequest);
    }

    return callback();
  }

  mapRequestToDependency(request) {
    let requestToHandle = _ops.wpackioRequestToHandle;

    if (this.options.gutenbergOptimized) {
      requestToHandle = _ops.defaultRequestToHandle;
    }

    const scriptDependency = requestToHandle(request);

    if (scriptDependency) {
      return scriptDependency;
    }

    return request;
  }

  stringify(asset) {
    return JSON.stringify(asset, null, 2);
  }
  /**
   * Write the asset manifest to the file system.
   *
   * @param {string} destination
   */


  async writeTo(destination, content) {
    await (0, _ops.lock)(destination);
    await _fs.default.promises.mkdir(_path.default.dirname(destination), {
      recursive: true
    });
    await _fs.default.promises.writeFile(destination, content, {
      encoding: 'utf8'
    });
    await (0, _ops.unlock)(destination);
  }

  handleEmit(compilation) {
    if (!this.compiler) {
      return;
    } // Process each entry point independently.


    for (const [entrypointName, entrypoint] of compilation.entrypoints.entries()) {
      const entrypointExternalizedWpDeps = new Set();

      const processModule = req => {
        const {
          userRequest
        } = req;

        if (this.externalizedDeps.has(userRequest)) {
          const scriptDependency = this.mapRequestToDependency(userRequest);
          entrypointExternalizedWpDeps.add(scriptDependency);
        }
      }; // Search for externalized modules in all chunks.


      for (const chunk of entrypoint.chunks) {
        for (const chunkModule of chunk.modulesIterable) {
          processModule(chunkModule); // loop through submodules of ConcatenatedModule

          if (chunkModule.modules) {
            for (const concatModule of chunkModule.modules) {
              processModule(concatModule);
            }
          }
        }
      }

      const runtimeChunk = entrypoint.getRuntimeChunk();
      const assetData = {
        // Get a sorted array so we can produce a stable, stringified representation.
        dependencies: Array.from(entrypointExternalizedWpDeps).sort(),
        version: runtimeChunk.hash
      };
      const assetString = this.stringify(assetData);
      const fileName = `${entrypointName.split('?', 2)[0]}.dependencies.wp.json`;

      const outputPath = _path.default.resolve(this.compiler.outputPath, this.options.appDir, fileName);

      const assetPath = compilation.getPath(outputPath, {
        chunk: {
          name: 'dependencies.wp'
        },
        filename: fileName,
        contentHash: ''
      });
      this.assetDependenciesData.push({
        content: assetString,
        path: assetPath
      });
    }
  }

  async handleAfterEmit() {
    if (!this.assetDependenciesData.length) {
      return;
    }

    for (const data of this.assetDependenciesData) {
      // eslint-disable-next-line no-await-in-loop
      await this.writeTo(data.path, data.content);
    }
  }

  apply(compiler) {
    this.compiler = compiler;
    this.externalsPlugin.apply(compiler);
    compiler.hooks.emit.tap(this.constructor.name, this.handleEmit.bind(this));
    compiler.hooks.afterEmit.tapPromise(this.constructor.name, this.handleAfterEmit.bind(this));
  }

}

exports.DependencyExtractionWebpackPlugin = DependencyExtractionWebpackPlugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wbHVnaW5zL0RlcGVuZGVuY3lFeHRyYWN0aW9uV2VicGFja1BsdWdpbi50cyJdLCJuYW1lcyI6WyJEZXBlbmRlbmN5RXh0cmFjdGlvbldlYnBhY2tQbHVnaW4iLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJndXRlbmJlcmdPcHRpbWl6ZWQiLCJhcHBEaXIiLCJleHRlcm5hbGl6ZWREZXBzIiwiU2V0IiwiZXh0ZXJuYWxzUGx1Z2luIiwid2VicGFjayIsIkV4dGVybmFsc1BsdWdpbiIsImV4dGVybmFsaXplV3BEZXBzIiwiYmluZCIsImFzc2V0RGVwZW5kZW5jaWVzRGF0YSIsIl9jb250ZXh0IiwicmVxdWVzdCIsImNhbGxiYWNrIiwiZXh0ZXJuYWxSZXF1ZXN0IiwiYWRkIiwibWFwUmVxdWVzdFRvRGVwZW5kZW5jeSIsInJlcXVlc3RUb0hhbmRsZSIsIndwYWNraW9SZXF1ZXN0VG9IYW5kbGUiLCJkZWZhdWx0UmVxdWVzdFRvSGFuZGxlIiwic2NyaXB0RGVwZW5kZW5jeSIsInN0cmluZ2lmeSIsImFzc2V0IiwiSlNPTiIsIndyaXRlVG8iLCJkZXN0aW5hdGlvbiIsImNvbnRlbnQiLCJmcyIsInByb21pc2VzIiwibWtkaXIiLCJwYXRoIiwiZGlybmFtZSIsInJlY3Vyc2l2ZSIsIndyaXRlRmlsZSIsImVuY29kaW5nIiwiaGFuZGxlRW1pdCIsImNvbXBpbGF0aW9uIiwiY29tcGlsZXIiLCJlbnRyeXBvaW50TmFtZSIsImVudHJ5cG9pbnQiLCJlbnRyeXBvaW50cyIsImVudHJpZXMiLCJlbnRyeXBvaW50RXh0ZXJuYWxpemVkV3BEZXBzIiwicHJvY2Vzc01vZHVsZSIsInJlcSIsInVzZXJSZXF1ZXN0IiwiaGFzIiwiY2h1bmsiLCJjaHVua3MiLCJjaHVua01vZHVsZSIsIm1vZHVsZXNJdGVyYWJsZSIsIm1vZHVsZXMiLCJjb25jYXRNb2R1bGUiLCJydW50aW1lQ2h1bmsiLCJnZXRSdW50aW1lQ2h1bmsiLCJhc3NldERhdGEiLCJkZXBlbmRlbmNpZXMiLCJBcnJheSIsImZyb20iLCJzb3J0IiwidmVyc2lvbiIsImhhc2giLCJhc3NldFN0cmluZyIsImZpbGVOYW1lIiwic3BsaXQiLCJvdXRwdXRQYXRoIiwicmVzb2x2ZSIsImFzc2V0UGF0aCIsImdldFBhdGgiLCJuYW1lIiwiZmlsZW5hbWUiLCJjb250ZW50SGFzaCIsInB1c2giLCJoYW5kbGVBZnRlckVtaXQiLCJsZW5ndGgiLCJkYXRhIiwiYXBwbHkiLCJob29rcyIsImVtaXQiLCJ0YXAiLCJhZnRlckVtaXQiLCJ0YXBQcm9taXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFjTyxNQUFNQSxpQ0FBTixDQUF3QztBQVc5Q0MsRUFBQUEsV0FBVyxDQUNWQyxPQUFpRCxHQUFHO0FBQ25EQyxJQUFBQSxrQkFBa0IsRUFBRSxLQUQrQjtBQUVuREMsSUFBQUEsTUFBTSxFQUFFO0FBRjJDLEdBRDFDLEVBS1Q7QUFBQTs7QUFBQTs7QUFBQSxzQ0FiMEMsSUFhMUM7O0FBQUE7O0FBQUE7O0FBQ0QsU0FBS0YsT0FBTCxxQkFDSUEsT0FESjtBQUlBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNFLFNBQUtHLGdCQUFMLEdBQXdCLElBQUlDLEdBQUosRUFBeEIsQ0FaQyxDQWNEOztBQUNBLFNBQUtDLGVBQUwsR0FBdUIsSUFBSUMsaUJBQVFDLGVBQVosQ0FDdEIsUUFEc0IsRUFFdEIsS0FBS0MsaUJBQUwsQ0FBdUJDLElBQXZCLENBQTRCLElBQTVCLENBRnNCLENBQXZCO0FBS0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQTs7QUFFREYsRUFBQUEsaUJBQWlCLENBQUNHLFFBQUQsRUFBZ0JDLE9BQWhCLEVBQWlDQyxRQUFqQyxFQUFnRDtBQUNoRSxRQUFJQyxlQUFlLEdBQUcscUNBQTJCRixPQUEzQixDQUF0Qjs7QUFFQSxRQUFJLEtBQUtaLE9BQUwsQ0FBYUMsa0JBQWpCLEVBQXFDO0FBQ3BDYSxNQUFBQSxlQUFlLEdBQUcs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LEdBQWdCQSxRQUFoQjtBQUVBLFNBQUtoQyxlQUFMLENBQXFCdUUsS0FBckIsQ0FBMkJ2QyxRQUEzQjtBQUVBQSxJQUFBQSxRQUFRLENBQUN3QyxLQUFULENBQWVDLElBQWYsQ0FBb0JDLEdBQXBCLENBQXdCLEtBQUtoRixXQUFMLENBQWlCc0UsSUFBekMsRUFBK0MsS0FBS2xDLFVBQUwsQ0FBZ0IxQixJQUFoQixDQUFxQixJQUFyQixDQUEvQztBQUVBNEIsSUFBQUEsUUFBUSxDQUFDd0MsS0FBVCxDQUFlRyxTQUFmLENBQXlCQyxVQUF6QixDQUNDLEtBQUtsRixXQUFMLENBQWlCc0UsSUFEbEIsRUFFQyxLQUFLSSxlQUFMLENBQXFCaEUsSUFBckIsQ0FBMEIsSUFBMUIsQ0FGRDtBQUlBOztBQXZLNkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuaW1wb3J0IHdlYnBhY2ssIHsgQ29tcGlsZXIgfSBmcm9tICd3ZWJwYWNrJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcblxuaW1wb3J0IHtcblx0d3BhY2tpb1JlcXVlc3RUb0hhbmRsZSxcblx0d3BhY2tpb1JlcXVlc3RzVG9FeHRlcm5hbHMsXG5cdGRlZmF1bHRSZXF1ZXN0VG9FeHRlcm5hbCxcblx0ZGVmYXVsdFJlcXVlc3RUb0hhbmRsZSxcblx0bG9jayxcblx0dW5sb2NrLFxufSBmcm9tICcuLi9kZXYtdXRpbHMvb3BzJztcblxudHlwZSBEZXBlbmRlbmN5RXh0cmFjdGlvbldlYnBhY2tQbHVnaW5PcHRpb25zID0ge1xuXHRhcHBEaXI6IHN0cmluZztcblx0Z3V0ZW5iZXJnT3B0aW1pemVkOiBib29sZWFuO1xufTtcblxuZXhwb3J0IGNsYXNzIERlcGVuZGVuY3lFeHRyYWN0aW9uV2VicGFja1BsdWdpbiB7XG5cdHByaXZhdGUgZXh0ZXJuYWxpemVkRGVwczogU2V0PHN0cmluZz47XG5cdHByaXZhdGUgZXh0ZXJuYWxzUGx1Z2luOiB3ZWJwYWNrLkV4dGVybmFsc1BsdWdpbjtcblx0cHJpdmF0ZSBjb21waWxlcjogd2VicGFjay5Db21waWxlciB8IG51bGwgPSBudWxsO1xuXG5cdHByaXZhdGUgYXNzZXREZXBlbmRlbmNpZXNEYXRhOiB7XG5cdFx0cGF0aDogc3RyaW5nO1xuXHRcdGNvbnRlbnQ6IHN0cmluZztcblx0fVtdO1xuXG5cdHByaXZhdGUgb3B0aW9uczogRGVwZW5kZW5jeUV4dHJhY3Rpb25XZWJwYWNrUGx1Z2luT3B0aW9ucztcblx0Y29uc3RydWN0b3IoXG5cdFx0b3B0aW9uczogRGVwZW5kZW5jeUV4dHJhY3Rpb25XZWJwYWNrUGx1Z2luT3B0aW9ucyA9IHtcblx0XHRcdGd1dGVuYmVyZ09wdGltaXplZDogZmFsc2UsXG5cdFx0XHRhcHBEaXI6ICcnLFxuXHRcdH1cblx0KSB7XG5cdFx0dGhpcy5vcHRpb25zID0ge1xuXHRcdFx0Li4ub3B0aW9ucyxcblx0XHR9O1xuXG5cdFx0Lypcblx0XHQgKiBUcmFjayByZXF1ZXN0cyB0aGF0IGFyZSBleHRlcm5hbGl6ZWQuXG5cdFx0ICpcblx0XHQgKiBCZWNhdXNlIHdlIGRvbid0IGhhdmUgYSBjbG9zZWQgc2V0IG9mIGRlcGVuZGVuY2llcywgd2UgbmVlZCB0byB0cmFjayB3aGF0IGhhc1xuXHRcdCAqIGJlZW4gZXh0ZXJuYWxpemVkIHNvIHdlIGNhbiByZWNvZ25pemUgdGhlbSBpbiBhIGxhdGVyIHBoYXNlIHdoZW4gdGhlIGRlcGVuZGVuY3lcblx0XHQgKiBsaXN0cyBhcmUgZ2VuZXJhdGVkLlxuXHRcdCAqL1xuXHRcdHRoaXMuZXh0ZXJuYWxpemVkRGVwcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5cdFx0Ly8gT2ZmbG9hZCBleHRlcm5hbGl6YXRpb24gd29yayB0byB0aGUgRXh0ZXJuYWxzUGx1Z2luLlxuXHRcdHRoaXMuZXh0ZXJuYWxzUGx1Z2luID0gbmV3IHdlYnBhY2suRXh0ZXJuYWxzUGx1Z2luKFxuXHRcdFx0J3dpbmRvdycsXG5cdFx0XHR0aGlzLmV4dGVybmFsaXplV3BEZXBzLmJpbmQodGhpcylcblx0XHQpO1xuXG5cdFx0dGhpcy5hc3NldERlcGVuZGVuY2llc0RhdGEgPSBbXTtcblx0fVxuXG5cdGV4dGVybmFsaXplV3BEZXBzKF9jb250ZXh0OiBhbnksIHJlcXVlc3Q6IHN0cmluZywgY2FsbGJhY2s6IGFueSkge1xuXHRcdGxldCBleHRlcm5hbFJlcXVlc3QgPSB3cGFja2lvUmVxdWVzdHNUb0V4dGVybmFscyhyZXF1ZXN0KTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ3V0ZW5iZXJnT3B0aW1pemVkKSB7XG5cdFx0XHRleHRlcm5hbFJlcXVlc3QgPSBkZWZhdWx0UmVxdWVzdFRvRXh0ZXJuYWwocmVxdWVzdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGV4dGVybmFsUmVxdWVzdCkge1xuXHRcdFx0dGhpcy5leHRlcm5hbGl6ZWREZXBzLmFkZChyZXF1ZXN0KTtcblxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGV4dGVybmFsUmVxdWVzdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhbGxiYWNrKCk7XG5cdH1cblxuXHRtYXBSZXF1ZXN0VG9EZXBlbmRlbmN5KHJlcXVlc3Q6IHN0cmluZykge1xuXHRcdGxldCByZXF1ZXN0VG9IYW5kbGUgPSB3cGFja2lvUmVxdWVzdFRvSGFuZGxlO1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ3V0ZW5iZXJnT3B0aW1pemVkKSB7XG5cdFx0XHRyZXF1ZXN0VG9IYW5kbGUgPSBkZWZhdWx0UmVxdWVzdFRvSGFuZGxlO1xuXHRcdH1cblx0XHRjb25zdCBzY3JpcHREZXBlbmRlbmN5ID0gcmVxdWVzdFRvSGFuZGxlKHJlcXVlc3QpO1xuXHRcdGlmIChzY3JpcHREZXBlbmRlbmN5KSB7XG5cdFx0XHRyZXR1cm4gc2NyaXB0RGVwZW5kZW5jeTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdH1cblxuXHRzdHJpbmdpZnkoYXNzZXQ6IGFueSkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhc3NldCwgbnVsbCwgMik7XG5cdH1cblxuXHQvKipcblx0ICogV3JpdGUgdGhlIGFzc2V0IG1hbmlmZXN0IHRvIHRoZSBmaWxlIHN5c3RlbS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uXG5cdCAqL1xuXHRhc3luYyB3cml0ZVRvKGRlc3RpbmF0aW9uOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xuXHRcdGF3YWl0IGxvY2soZGVzdGluYXRpb24pO1xuXHRcdGF3YWl0IGZzLnByb21pc2VzLm1rZGlyKHBhdGguZGlybmFtZShkZXN0aW5hdGlvbiksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXHRcdGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShkZXN0aW5hdGlvbiwgY29udGVudCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuXHRcdGF3YWl0IHVubG9jayhkZXN0aW5hdGlvbik7XG5cdH1cblxuXHRoYW5kbGVFbWl0KGNvbXBpbGF0aW9uOiB3ZWJwYWNrLmNvbXBpbGF0aW9uLkNvbXBpbGF0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLmNvbXBpbGVyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUHJvY2VzcyBlYWNoIGVudHJ5IHBvaW50IGluZGVwZW5kZW50bHkuXG5cdFx0Zm9yIChjb25zdCBbXG5cdFx0XHRlbnRyeXBvaW50TmFtZSxcblx0XHRcdGVudHJ5cG9pbnQsXG5cdFx0XSBvZiBjb21waWxhdGlvbi5lbnRyeXBvaW50cy5lbnRyaWVzKCkpIHtcblx0XHRcdGNvbnN0IGVudHJ5cG9pbnRFeHRlcm5hbGl6ZWRXcERlcHMgPSBuZXcgU2V0KCk7XG5cblx0XHRcdGNvbnN0IHByb2Nlc3NNb2R1bGUgPSAocmVxOiB7IHVzZXJSZXF1ZXN0OiBzdHJpbmcgfSkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHVzZXJSZXF1ZXN0IH0gPSByZXE7XG5cdFx0XHRcdGlmICh0aGlzLmV4dGVybmFsaXplZERlcHMuaGFzKHVzZXJSZXF1ZXN0KSkge1xuXHRcdFx0XHRcdGNvbnN0IHNjcmlwdERlcGVuZGVuY3kgPSB0aGlzLm1hcFJlcXVlc3RUb0RlcGVuZGVuY3kodXNlclJlcXVlc3QpO1xuXHRcdFx0XHRcdGVudHJ5cG9pbnRFeHRlcm5hbGl6ZWRXcERlcHMuYWRkKHNjcmlwdERlcGVuZGVuY3kpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBTZWFyY2ggZm9yIGV4dGVybmFsaXplZCBtb2R1bGVzIGluIGFsbCBjaHVua3MuXG5cdFx0XHRmb3IgKGNvbnN0IGNodW5rIG9mIGVudHJ5cG9pbnQuY2h1bmtzKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgY2h1bmtNb2R1bGUgb2YgY2h1bmsubW9kdWxlc0l0ZXJhYmxlKSB7XG5cdFx0XHRcdFx0cHJvY2Vzc01vZHVsZShjaHVua01vZHVsZSk7XG5cdFx0XHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHN1Ym1vZHVsZXMgb2YgQ29uY2F0ZW5hdGVkTW9kdWxlXG5cdFx0XHRcdFx0aWYgKGNodW5rTW9kdWxlLm1vZHVsZXMpIHtcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgY29uY2F0TW9kdWxlIG9mIGNodW5rTW9kdWxlLm1vZHVsZXMpIHtcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc01vZHVsZShjb25jYXRNb2R1bGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBydW50aW1lQ2h1bmsgPSBlbnRyeXBvaW50LmdldFJ1bnRpbWVDaHVuaygpO1xuXG5cdFx0XHRjb25zdCBhc3NldERhdGEgPSB7XG5cdFx0XHRcdC8vIEdldCBhIHNvcnRlZCBhcnJheSBzbyB3ZSBjYW4gcHJvZHVjZSBhIHN0YWJsZSwgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24uXG5cdFx0XHRcdGRlcGVuZGVuY2llczogQXJyYXkuZnJvbShlbnRyeXBvaW50RXh0ZXJuYWxpemVkV3BEZXBzKS5zb3J0KCksXG5cdFx0XHRcdHZlcnNpb246IHJ1bnRpbWVDaHVuay5oYXNoLFxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgYXNzZXRTdHJpbmcgPSB0aGlzLnN0cmluZ2lmeShhc3NldERhdGEpO1xuXG5cdFx0XHRjb25zdCBmaWxlTmFtZSA9IGAke1xuXHRcdFx0XHRlbnRyeXBvaW50TmFtZS5zcGxpdCgnPycsIDIpWzBdXG5cdFx0XHR9LmRlcGVuZGVuY2llcy53cC5qc29uYDtcblx0XHRcdGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLnJlc29sdmUoXG5cdFx0XHRcdHRoaXMuY29tcGlsZXIub3V0cHV0UGF0aCxcblx0XHRcdFx0dGhpcy5vcHRpb25zLmFwcERpcixcblx0XHRcdFx0ZmlsZU5hbWVcblx0XHRcdCk7XG5cdFx0XHRjb25zdCBhc3NldFBhdGggPSBjb21waWxhdGlvbi5nZXRQYXRoKG91dHB1dFBhdGgsIHtcblx0XHRcdFx0Y2h1bms6IHsgbmFtZTogJ2RlcGVuZGVuY2llcy53cCcgfSxcblx0XHRcdFx0ZmlsZW5hbWU6IGZpbGVOYW1lLFxuXHRcdFx0XHRjb250ZW50SGFzaDogJycsXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuYXNzZXREZXBlbmRlbmNpZXNEYXRhLnB1c2goe1xuXHRcdFx0XHRjb250ZW50OiBhc3NldFN0cmluZyxcblx0XHRcdFx0cGF0aDogYXNzZXRQYXRoLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgaGFuZGxlQWZ0ZXJFbWl0KCkge1xuXHRcdGlmICghdGhpcy5hc3NldERlcGVuZGVuY2llc0RhdGEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGZvciAoY29uc3QgZGF0YSBvZiB0aGlzLmFzc2V0RGVwZW5kZW5jaWVzRGF0YSkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRcdGF3YWl0IHRoaXMud3JpdGVUbyhkYXRhLnBhdGgsIGRhdGEuY29udGVudCk7XG5cdFx0fVxuXHR9XG5cblx0YXBwbHkoY29tcGlsZXI6IENvbXBpbGVyKSB7XG5cdFx0dGhpcy5jb21waWxlciA9IGNvbXBpbGVyO1xuXG5cdFx0dGhpcy5leHRlcm5hbHNQbHVnaW4uYXBwbHkoY29tcGlsZXIpO1xuXG5cdFx0Y29tcGlsZXIuaG9va3MuZW1pdC50YXAodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCB0aGlzLmhhbmRsZUVtaXQuYmluZCh0aGlzKSk7XG5cblx0XHRjb21waWxlci5ob29rcy5hZnRlckVtaXQudGFwUHJvbWlzZShcblx0XHRcdHRoaXMuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdHRoaXMuaGFuZGxlQWZ0ZXJFbWl0LmJpbmQodGhpcylcblx0XHQpO1xuXHR9XG59XG4iXX0=